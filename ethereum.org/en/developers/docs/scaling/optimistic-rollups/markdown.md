Skip to main content

[](/en/)

  * Learn
  * Use
  * Build
  * Participate
  * Research

Search```K`

Languages EN

Change page

[Overview](/en/developers/docs/)

Foundational topics

[Intro to Ethereum](/en/developers/docs/intro-to-ethereum/)

[Intro to Ether](/en/developers/docs/intro-to-ether/)

[Intro to dapps](/en/developers/docs/dapps/)

[Web2 vs Web3](/en/developers/docs/web2-vs-web3/)

[Accounts](/en/developers/docs/accounts/)

[Transactions](/en/developers/docs/transactions/)

[Blocks](/en/developers/docs/blocks/)

[Ethereum virtual machine (EVM)](/en/developers/docs/evm/)

[Opcodes](/en/developers/docs/evm/opcodes/)

[Gas](/en/developers/docs/gas/)

[Nodes and clients](/en/developers/docs/nodes-and-clients/)

[Run a node](/en/developers/docs/nodes-and-clients/run-a-node/)

[Client diversity](/en/developers/docs/nodes-and-clients/client-diversity/)

[Nodes as a service](/en/developers/docs/nodes-and-clients/nodes-as-a-
service/)

[Node architecture](/en/developers/docs/nodes-and-clients/node-architecture/)

[Light clients](/en/developers/docs/nodes-and-clients/light-clients/)

[Archive nodes](/en/developers/docs/nodes-and-clients/archive-nodes/)

[Bootnodes](/en/developers/docs/nodes-and-clients/bootnodes/)

[Networks](/en/developers/docs/networks/)

[Consensus mechanisms](/en/developers/docs/consensus-mechanisms/)

[Proof-of-work](/en/developers/docs/consensus-mechanisms/pow/)

[Mining](/en/developers/docs/consensus-mechanisms/pow/mining/)

[Mining algorithms](/en/developers/docs/consensus-
mechanisms/pow/mining/mining-algorithms/)

[Dagger-Hashimoto](/en/developers/docs/consensus-mechanisms/pow/mining/mining-
algorithms/dagger-hashimoto/)

[Ethash](/en/developers/docs/consensus-mechanisms/pow/mining/mining-
algorithms/ethash/)

[Proof-of-stake](/en/developers/docs/consensus-mechanisms/pos/)

[Gasper](/en/developers/docs/consensus-mechanisms/pos/gasper/)

[Weak subjectivity](/en/developers/docs/consensus-mechanisms/pos/weak-
subjectivity/)

[Attestations](/en/developers/docs/consensus-mechanisms/pos/attestations/)

[PoS rewards and penalties](/en/developers/docs/consensus-
mechanisms/pos/rewards-and-penalties/)

[PoS attack and defense](/en/developers/docs/consensus-mechanisms/pos/attack-
and-defense/)

[Keys](/en/developers/docs/consensus-mechanisms/pos/keys/)

[Proof-of-stake versus proof-of-work](/en/developers/docs/consensus-
mechanisms/pos/pos-vs-pow/)

[Block proposal](/en/developers/docs/consensus-mechanisms/pos/block-proposal/)

[Proof-of-stake FAQs](/en/developers/docs/consensus-mechanisms/pos/faqs/)

[Proof-of-authority](/en/developers/docs/consensus-mechanisms/poa/)

Ethereum stack

[Intro to the stack](/en/developers/docs/ethereum-stack/)

[Smart contracts](/en/developers/docs/smart-contracts/)

[Smart contract languages](/en/developers/docs/smart-contracts/languages/)

[Smart contract anatomy](/en/developers/docs/smart-contracts/anatomy/)

[Smart contracts libraries](/en/developers/docs/smart-contracts/libraries/)

[Testing smart contracts](/en/developers/docs/smart-contracts/testing/)

[Compiling smart contracts](/en/developers/docs/smart-contracts/compiling/)

[Deploying smart contracts](/en/developers/docs/smart-contracts/deploying/)

[Verifying smart contracts](/en/developers/docs/smart-contracts/verifying/)

[Upgrading smart contracts](/en/developers/docs/smart-contracts/upgrading/)

[Smart contract security](/en/developers/docs/smart-contracts/security/)

[Smart contract formal verification](/en/developers/docs/smart-
contracts/formal-verification/)

[Composability](/en/developers/docs/smart-contracts/composability/)

[Development networks](/en/developers/docs/development-networks/)

[Development frameworks](/en/developers/docs/frameworks/)

Ethereum client APIs

[JavaScript APIs](/en/developers/docs/apis/javascript/)

[Backend APIs](/en/developers/docs/apis/backend/)

[JSON-RPC](/en/developers/docs/apis/json-rpc/)

[Data and analytics](/en/developers/docs/data-and-analytics/)

[Block explorers](/en/developers/docs/data-and-analytics/block-explorers/)

[Storage](/en/developers/docs/storage/)

[Integrated Development Environments (IDEs)](/en/developers/docs/ides/)

[Programming languages](/en/developers/docs/programming-languages/)

[Dart](/en/developers/docs/programming-languages/dart/)

[Delphi](/en/developers/docs/programming-languages/delphi/)

[.NET](/en/developers/docs/programming-languages/dot-net/)

[Golang](/en/developers/docs/programming-languages/golang/)

[Java](/en/developers/docs/programming-languages/java/)

[JavaScript](/en/developers/docs/programming-languages/javascript/)

[Python](/en/developers/docs/programming-languages/python/)

[Ruby](/en/developers/docs/programming-languages/ruby/)

[Rust](/en/developers/docs/programming-languages/rust/)

Advanced

[Bridges](/en/developers/docs/bridges/)

[Standards](/en/developers/docs/standards/)

[Token standards](/en/developers/docs/standards/tokens/)

[ERC-20: Fungible Tokens](/en/developers/docs/standards/tokens/erc-20/)

[ERC-721: NFTs](/en/developers/docs/standards/tokens/erc-721/)

[ERC-777](/en/developers/docs/standards/tokens/erc-777/)

[ERC-1155](/en/developers/docs/standards/tokens/erc-1155/)

[ERC-4626](/en/developers/docs/standards/tokens/erc-4626/)

[Maximal extractable value (MEV)](/en/developers/docs/mev/)

[Oracles](/en/developers/docs/oracles/)

[Scaling](/en/developers/docs/scaling/)

[Optimistic rollups](/en/developers/docs/scaling/optimistic-rollups/)

[Zero-knowledge rollups](/en/developers/docs/scaling/zk-rollups/)

[State channels](/en/developers/docs/scaling/state-channels/)

[Sidechains](/en/developers/docs/scaling/sidechains/)

[Plasma](/en/developers/docs/scaling/plasma/)

[Validium](/en/developers/docs/scaling/validium/)

[Data availability](/en/developers/docs/data-availability/)

[Networking layer](/en/developers/docs/networking-layer/)

[Network addresses](/en/developers/docs/networking-layer/network-addresses/)

[Portal Network](/en/developers/docs/networking-layer/portal-network/)

[Data structures and encoding](/en/developers/docs/data-structures-and-
encoding/)

[Patricia Merkle Trie](/en/developers/docs/data-structures-and-
encoding/patricia-merkle-trie/)

[Recursive-length prefix (RLP)](/en/developers/docs/data-structures-and-
encoding/rlp/)

[Simple serialize (SSZ)](/en/developers/docs/data-structures-and-
encoding/ssz/)

[Web3 secret storage definition](/en/developers/docs/data-structures-and-
encoding/web3-secret-storage/)

Design fundamentals

[Intro to design and UX](/en/developers/docs/design-and-ux/)

# Optimistic Rollups

w

Last edit: [@wackerow(opens in a new tab)](https://github.com/wackerow), May
7, 2024

See contributors

On this page

  * Prerequisites
  * What is an optimistic rollup?
  * How do optimistic rollups interact with Ethereum?
    * Data availability
    * Censorship resistance
    * Settlement
  * How do optimistic rollups work?
    * Transaction execution and aggregation
    * State commitments
    * Fraud proving
    * L1/L2 interoperability
  * How do optimistic rollup fees work?
  * How do optimistic rollups scale Ethereum?
    * Pros and cons of optimistic rollups
    * A visual explanation of optimistic rollups
    * Use Optimistic rollups
  * Further reading on optimistic rollups

Optimistic rollups are layer 2 (L2) protocols designed to extend the
throughput of Ethereum's base layer. They reduce computation on the main
Ethereum chain by processing transactions off-chain, offering significant
improvements in processing speeds. Unlike other scaling solutions, such as
[sidechains](/en/developers/docs/scaling/sidechains/), optimistic rollups
derive security from Mainnet by publishing transaction results on-chain, or
[plasma chains](/en/developers/docs/scaling/plasma/), which also verify
transactions on Ethereum with fraud proofs, but store transaction data
elsewhere.

As computation is the slow, expensive part of using Ethereum, optimistic
rollups can offer up to 10-100x improvements in scalability. Optimistic
rollups also write transactions to Ethereum as `calldata` or in
[blobs](/en/roadmap/danksharding/), reducing gas costs for users.

## Prerequisites

You should have read and understood our pages on [Ethereum
scaling](/en/developers/docs/scaling/) and [layer 2](/en/layer-2/).

## What is an optimistic rollup?

An optimistic rollup is an approach to scaling Ethereum that involves moving
computation and state storage off-chain. Optimistic rollups execute
transactions outside of Ethereum, but post transaction data to Mainnet as
`calldata` or in [blobs](/en/roadmap/danksharding/).

Optimistic rollup operators bundle multiple off-chain transactions together in
large batches before submitting to Ethereum. This approach enables spreading
fixed costs across multiple transactions in each batch, reducing fees for end-
users. Optimistic rollups also use compression techniques to reduce the amount
of data posted on Ethereum.

Optimistic rollups are considered â€œoptimisticâ€ because they assume off-chain
transactions are valid and don't publish proofs of validity for transaction
batches posted on-chain. This separates optimistic rollups from [zero-
knowledge rollups](/en/developers/docs/scaling/zk-rollups/) that publish
cryptographic _proofs of validity_ for off-chain transactions.

Optimistic rollups instead rely on a fraud-proving scheme to detect cases
where transactions are not calculated correctly. After a rollup batch is
submitted on Ethereum, there's a time window (called a challenge period)
during which anyone can challenge the results of a rollup transaction by
computing a _fraud proof_.

If the fraud proof succeeds, the rollup protocol re-executes the
transaction(s) and updates the rollup's state accordingly. The other effect of
a successful fraud proof is that the sequencer responsible for including the
incorrectly executed transaction in a block receives a penalty.

If the rollup batch remains unchallenged (i.e., all transactions are correctly
executed) after the challenge period elapses, it is deemed valid and accepted
on Ethereum. Others can continue to build on an unconfirmed rollup block, but
with a caveat: transaction results will be reversed if based on an incorrectly
executed transaction published previously.

## How do optimistic rollups interact with Ethereum?

Optimistic rollups are [off-chain scaling
solutions](/en/developers/docs/scaling/#off-chain-scaling) built to operate on
top of Ethereum. Each optimistic rollup is managed by a set of smart contracts
deployed on the Ethereum network. Optimistic rollups process transactions off
the main Ethereum chain, but post off-chain transactions (in batches) to an
on-chain rollup contract. Like the Ethereum blockchain, this transaction
record is immutable and forms the "optimistic rollup chain."

The architecture of an optimistic rollup comprises the following parts:

**On-chain contracts** : The optimistic rollups's operation is controlled by
smart contracts running on Ethereum. This includes contracts that store rollup
blocks, monitor state updates on the rollup, and track user deposits. In this
sense, Ethereum serves as the base layer or "layer 1" for optimistic rollups.

**Off-chain virtual machine (VM)** : Although contracts managing the
optimistic rollup protocol run on Ethereum, the rollup protocol performs
computation and state storage on another virtual machine separate from the
[Ethereum Virtual Machine](/en/developers/docs/evm/). The off-chain VM is
where applications live and state changes are executed; it serves as the upper
layer or "layer 2" for an optimistic rollup.

As optimistic rollups are designed to run programs either written or compiled
for the EVM, the off-chain VM incorporates many EVM design specs.
Additionally, fraud proofs computed on-chain allows the Ethereum network to
enforce the validity of state changes computed in the off-chain VM.

Optimistic rollups are described as 'hybrid scaling solutions' because, while
they exist as separate protocols, their security properties are derived from
Ethereum. Among other things, Ethereum guarantees the correctness of a
rollupâ€™s off-chain computation and the availability of data behind the
computation. This makes optimistic rollups more secure than pure off-chain
scaling protocols (e.g.,
[sidechains](/en/developers/docs/scaling/sidechains/)) that do not rely on
Ethereum for security.

Optimistic rollups rely on the main Ethereum protocol for the following:

### Data availability

As mentioned, optimistic rollups post transaction data to Ethereum as
`calldata` or [blobs](/en/roadmap/danksharding/). Since the rollup chain's
execution is based on submitted transactions, anyone can use this
informationâ€”anchored on Ethereumâ€™s base layerâ€”to execute the rollupâ€™s state
and verify the correctness of state transitions.

[Data availability](/en/developers/docs/data-availability/) is critical
because without access to state data, challengers cannot construct fraud
proofs to dispute invalid rollup operations. With Ethereum providing data
availability, the risk of rollup operators getting away with malicious acts
(e.g., submitting invalid blocks) is reduced.

### Censorship resistance

Optimistic rollups also rely on Ethereum for censorship resistance. In an
optimistic rollup a centralized entity (the operator) is responsible for
processing transactions and submitting rollup blocks to Ethereum. This has
some implications:

  * Rollup operators can censor users by going offline completely, or by refusing to either produce blocks that include certain transactions in them.

  * Rollup operators can prevent users from withdrawing funds deposited in the rollup contract by withholding state data necessary to Merkle proofs of ownership. Withholding state data can also conceal the rollupâ€™s state from users and prevent them from interacting with the rollup.

Optimistic rollups solve this problem by forcing operators to publish data
associated with state updates on Ethereum. Publishing rollup data on-chain has
the following benefits:

  * If an optimistic rollup operator goes offline or stops producing transaction batches, another node can use available data to reproduce the rollupâ€™s last state and continue block production.

  * Users can use transaction data to create Merkle proofs proving ownership of funds and withdraw their assets from the rollup.

  * Users can also submit their transactions on L1 instead of to the sequencer, in which case the sequencer has to include the transaction within a certain time limit to continue to produce valid blocks.

### Settlement

Another role Ethereum plays in the context of optimistic rollups is that of a
settlement layer. A settlement layer anchors the entire blockchain ecosystem,
establishes security, and provides objective finality if a dispute occurs on
another chain (optimistic rollups in this case) that requires arbitration.

Ethereum Mainnet provides a hub for optimistic rollups to verify fraud proofs
and resolve disputes. Moreover, transactions conducted on the rollup are only
final _after_ the rollup block is accepted on Ethereum. Once a rollup
transaction is committed to Ethereumâ€™s base layer, it cannot be rolled back
(except in the highly unlikely case of a chain reorganization).

## How do optimistic rollups work?

### Transaction execution and aggregation

Users submit transactions to â€œoperatorsâ€, which are nodes responsible for
processing transactions on the optimistic rollup. Also known as a â€œvalidatorâ€
or â€œaggregatorâ€, the operator aggregates transactions, compresses the
underlying data, and publishes the block on Ethereum.

Although anyone can become a validator, optimistic rollup validators must
provide a bond before producing blocks, much like a [proof-of-stake
system](/en/developers/docs/consensus-mechanisms/pos/). This bond can be
slashed if the validator posts an invalid block or builds on an old-but-
invalid block (even if their block is valid). This way optimistic rollups
utilize cryptoeconomic incentives to ensure validators act honestly.

Other validators on the optimistic rollup chain are expected to execute the
submitted transactions using their copy of the rollupâ€™s state. If a
validatorâ€™s final state is different from the operatorâ€™s proposed state, they
can start a challenge and compute a fraud proof.

Some optimistic rollups may forgo a permissionless validator system and use a
single â€œsequencerâ€ to execute the chain. Like a validator, the sequencer
processes transactions, produces rollup blocks, and submits rollup
transactions to the L1 chain (Ethereum).

The sequencer is different from a regular rollup operator because they have
greater control over the ordering of transactions. Also, the sequencer has
priority access to the rollup chain and is the only entity authorized to
submit transactions to the on-chain contract. Transactions from non-sequencer
nodes or regular users are simply queued up in a separate inbox until the
sequencer includes them in a new batch.

#### Submitting rollup blocks to Ethereum

As mentioned, the operator of an optimistic rollup bundles off-chain
transactions into a batch and sends it to Ethereum for notarization. This
process involves compressing transaction-related data and publishing it on
Ethereum as `calldata` or in blobs.

`calldata` is a non-modifiable, non-persistent area in a smart contract that
behaves mostly like [memory](/en/developers/docs/smart-
contracts/anatomy/#memory). While `calldata` persists on-chain as part of the
blockchain's [history logs(opens in a new
tab)](https://docs.soliditylang.org/en/latest/introduction-to-smart-
contracts.html?highlight=memory#logs), it is not stored as a part of
Ethereum's state. Because `calldata` does not touch any part of Ethereum's
state, it is cheaper than state for storing data on-chain.

The `calldata` keyword is also used in Solidity to pass arguments to a smart
contract function at execution time. `calldata` identifies the function being
called during a transaction and holds inputs to the function in the form of an
arbitrary sequence of bytes.

In the context of optimistic rollups, `calldata` is used to send compressed
transaction data to the on-chain contract. The rollup operator adds a new
batch by calling the required function in the rollup contract and passing the
compressed data as function arguments. Using `calldata` reduces user fees
since most costs that rollups incur come from storing data on-chain.

Here is [an example(opens in a new
tab)](https://etherscan.io/tx/0x9102bfce17c58b5fc1c974c24b6bb7a924fb5fbd7c4cd2f675911c27422a5591)
of a rollup batch submission to show how this concept works. The sequencer
invoked the `appendSequencerBatch()` method and passed the compressed
transaction data as inputs using `calldata`.

Some rollups now use blobs to post batches of transactions to Ethereum.

Blobs are non-modifiable and non-persistent (just like `calldata`) but are
pruned from history after ~18 days. For more information on blobs, see
[Danksharding](/en/roadmap/danksharding/).

### State commitments

At any point in time, the optimistic rollupâ€™s state (accounts, balances,
contract code, etc.) is organized as a [Merkle tree](/en/whitepaper/#merkle-
trees) called a â€œstate treeâ€. The root of this Merkle tree (state root), which
references the rollupâ€™s latest state, is hashed and stored in the rollup
contract. Every state transition on the chain produces a new rollup state,
which an operator commits to by computing a new state root.

The operator is required to submit both old state roots and new state roots
when posting batches. If the old state root matches the existing state root in
the on-chain contract, the latter is discarded and replaced with the new state
root.

The rollup operator is also required to commit a Merkle root for the
transaction batch itself. This allows anyone to prove the inclusion of a
transaction in the batch (on L1) by presenting a [Merkle
proof](/en/developers/tutorials/merkle-proofs-for-offline-data-integrity/).

State commitments, especially state roots, are necessary for proving the
correctness of state changes in an optimistic rollup. The rollup contract
accepts new state roots from operators immediately after they are posted, but
can later delete invalid state roots to restore the rollup to its correct
state.

### Fraud proving

As explained, optimistic rollups allow anyone to publish blocks without
providing proofs of validity. However, to ensure the chain remains safe,
optimistic rollups specify a time window during which anyone can dispute a
state transition. Hence, rollup blocks are called â€œassertionsâ€ since anyone
can dispute their validity.

If someone disputes an assertion, then the rollup protocol will initiate the
fraud proof computation. Every type of fraud proof is interactiveâ€”someone must
post an assertion before another person can challenge it. The difference lies
in how many rounds of interaction are required to compute the fraud proof.

Single-round interactive proving schemes replay disputed transactions on L1 to
detect invalid assertions. The rollup protocol emulates the re-execution of
the disputed transaction on L1 (Ethereum) using a verifier contract, with the
computed state root determining who wins the challenge. If the challenger's
claim about the rollupâ€™s correct state is correct, the operator is penalized
by having their bond slashed.

However, re-executing transactions on L1 to detect fraud requires publishing
state commitments for individual transactions and increases the data rollups
must publish on-chain. Replaying transactions also incurs significant gas
costs. For these reasons, optimistic rollups are switching to multi-round
interactive proving, which achieves the same objective (i.e., detecting
invalid rollup operations) with more efficiency.

#### Multi-round interactive proving

Multi-round interactive proving involves a back-and-forth protocol between the
asserter and challenger overseen by an L1 verifier contract, which ultimately
decides the lying party. After an L2 node challenges an assertion, the
asserter is required to divide the disputed assertion into two equal halves.
Each individual assertion in this case will contain as many steps of
computation as the other.

The challenger will then choose what assertion it wants to challenge. The
dividing process (called a â€œbisection protocolâ€) continues until both parties
are disputing an assertion about a _single_ step of execution. At this point,
the L1 contract will resolve the dispute by evaluating the instruction (and
its result) to catch the fraudulent party.

The asserter is required to provide a â€œone-step proofâ€ verifying the validity
of the disputed single-step computation. If the asserter fails to provide the
one-step proof, or the L1 verifier deems the proof invalid, they lose the
challenge.

Some notes about this type of fraud proof:

  1. Multi-round interactive fraud proving is considered efficient because it minimizes the work the L1 chain must do in dispute arbitration. Instead of replaying the entire transaction, the L1 chain only needs to re-execute one step in the rollup's execution.

  2. Bisection protocols reduce the amount of data posted on-chain (no need to publish state commits for every transaction). Also, optimistic rollup transactions are not constrained by Ethereum's gas limit. Conversely, optimistic rollups re-executing transactions must make sure an L2 transaction has a lower gas limit to emulate its execution within a single Ethereum transaction.

  3. Part of the malicious asserter's bond is awarded to the challenger, while the other part is burned. The burning prevents collusion among validators; if two validators collude to initiate bogus challenges, they will still forfeit a considerable chunk of the entire stake.

  4. Multi-round interactive proving requires both parties (the asserter and the challenger) to make moves within the specified time window. Failure to act before the deadline expires causes the defaulting party to forfeit the challenge.

#### Why fraud proofs matter for optimistic rollups

Fraud proofs are important because they facilitate _trustless finality_ in
optimistic rollups. Trustless finality is a quality of optimistic rollups that
guarantees that a transactionâ€”so long as itâ€™s validâ€”will eventually be
confirmed.

Malicious nodes can try to delay the confirmation of a valid rollup block by
starting false challenges. However, fraud proofs will eventually prove the
rollup blockâ€™s validity and cause it to be confirmed.

This also relates to another security property of optimistic rollups: the
validity of the chain relies on the existence of _one_ honest node. The honest
node can advance the chain correctly by either posting valid assertions or
disputing invalid assertions. Whatever the case, malicious nodes who enter
into disputes with the honest node will lose their stakes during the fraud
proving process.

### L1/L2 interoperability

Optimistic rollups are designed for interoperability with Ethereum Mainnet and
allow users to pass messages and arbitrary data between L1 and L2. They are
also compatible with the EVM, so you can port existing
[dapps](/en/developers/docs/dapps/) to optimistic rollups or create new dapps
using Ethereum development tools.

#### 1\. Asset movement

##### Entering the rollup

To use an optimistic rollup, users deposit ETH, ERC-20 tokens, and other
accepted assets in the rollupâ€™s [bridge](/en/developers/docs/bridges/)
contract on L1. The bridge contract will relay the transaction to L2, where an
equivalent amount of assets is minted and sent to the userâ€™s chosen address on
the optimistic rollup.

User-generated transactions (like an L1 > L2 deposit) are usually queued until
the sequencer re-submits them to the rollup contract. However, to preserve
censorship resistance, optimistic rollups allow users to submit a transaction
directly to the on-chain rollup contract if it has been delayed past the
maximum time allowed.

Some optimistic rollups adopt a more straightforward approach to prevent
sequencers from censoring users. Here, a block is defined by all transactions
submitted to the L1 contract since the previous block (e.g., deposits) in
addition to the transactions processed on the rollup chain. If a sequencer
ignores an L1 transaction, it will publish the (provably) wrong state root;
therefore, sequencers cannot delay user-generated messages once posted on L1.

##### Exiting the rollup

Withdrawing from an optimistic rollup to Ethereum is more difficult owing to
the fraud proving scheme. If a user initiates an L2 > L1 transaction to
withdraw funds escrowed on L1, they must wait until the challenge
periodâ€”lasting roughly seven daysâ€”elapses. Nevertheless, the withdrawal
process itself is fairly straightforward.

After the withdrawal request is initiated on the L2 rollup, the transaction is
included in the next batch, while the userâ€™s assets on the rollup are burned.
Once the batch is published on Ethereum, the user can compute a Merkle proof
verifying the inclusion of their exit transaction in the block. Then it is a
matter of waiting through the delay period to finalize the transaction on L1
and withdraw funds to Mainnet.

To avoid waiting a week before withdrawing funds to Ethereum, optimistic
rollup users can employ a **liquidity provider** (LP). A liquidity provider
assumes ownership of a pending L2 withdrawal and pays the user on L1 (in
exchange for a fee).

Liquidity providers can check the validity of the userâ€™s withdrawal request
(by executing the chain themselves) before releasing funds. This way they have
assurances that the transaction will be confirmed eventually (i.e., trustless
finality).

#### 2\. EVM compatibility

For developers, the advantage of optimistic rollups is their compatibilityâ€”or,
better still, equivalenceâ€”with the [Ethereum Virtual Machine
(EVM)](/en/developers/docs/evm/). EVM-compatible rollups comply with
specifications in the [Ethereum Yellow Paper(opens in a new
tab)](https://ethereum.github.io/yellowpaper/paper.pdf) and support the EVM at
the bytecode level.

EVM-compatibility in optimistic rollups has the following benefits:

i. Developers can migrate existing smart contracts on Ethereum to optimistic
rollup chains without having to modify codebases extensively. This can save
development teams time when deploying Ethereum smart contracts on L2.

ii. Developers and project teams using optimistic rollups can take advantage
of Ethereum's infrastructure. This includes programming languages, code
libraries, testing tools, client software, deployment infrastructure, and so
on.

Using existing tooling is important because these tools have been extensively
audited, debugged, and improved over the years. It also removes the need for
Ethereum developers to learn how to build with an entirely new development
stack.

#### 3\. Cross-chain contract calls

Users (externally owned accounts) interact with L2 contracts by submitting a
transaction to the rollup contract or having a sequencer or validator do it
for them. Optimistic rollups also allow contract accounts on Ethereum to
interact with L2 contracts using bridging contracts to relay messages and pass
data between L1 and L2. This means you can program an L1 contract on Ethereum
Mainnet to invoke functions belonging to contracts on an L2 optimistic rollup.

Cross-chain contract calls happen asynchronouslyâ€”meaning the call is initiated
first, then executed at a later time. This is different from calls between the
two contracts on Ethereum, where the call produces results immediately.

An example of a cross-chain contract call is the token deposit described
earlier. A contract on L1 escrows the user's tokens and sends a message to a
paired L2 contract to mint an equal amount of tokens on the rollup.

As cross-chain message calls result in contract execution, the sender is
usually required to cover [gas costs](/en/developers/docs/gas/) for
computation. It is advisable to set a high gas limit to prevent the
transaction from failing on the target chain. The token bridging scenario is a
good example; if the L1 side of the transaction (depositing the tokens) works,
but the L2 side (minting new tokens) fails due to low gas, the deposit becomes
irrecoverable.

Finally, we should note that L2 > L1 message calls between contracts need to
account for delays (L1 > L2 calls are typically executed after some minutes).
This is because messages sent to Mainnet from the optimistic rollup cannot be
executed until the challenge window expires.

## How do optimistic rollup fees work?

Optimistic rollups use a gas fee scheme, much like Ethereum, to denote how
much users pay per transaction. Fees charged on optimistic rollups depends on
the following components:

  1. **State write** : Optimistic rollups publish transaction data and block headers (consisting of the previous block header hash, state root, batch root) to Ethereum as `calldata`. The minimum cost of an Ethereum transaction is 21,000 gas. Optimistic rollups can reduce the cost of writing the transaction to L1 by batching multiple transactions in a single block (which amortizes the 21k gas over multiple user transactions).

  2. **`calldata`** : Beyond the base transaction fee, the cost of each state write depends on the size of `calldata` posted to L1. `calldata` costs are currently governed by [EIP-1559(opens in a new tab)](https://eips.ethereum.org/EIPS/eip-1559), which stipulates a cost of 16 gas for non-zero bytes and 4 gas for zero bytes of `calldata`, respectively. To reduce user fees, rollup operators compress transactions to reduce the number of `calldata` bytes published on Ethereum.

  3. **L2 operator fees** : This is the amount paid to the rollup nodes as compensation for computational costs incurred in processing transactions, much like gas fees on Ethereum. Rollup nodes charge lower transaction fees since L2s have higher processing capacities and aren't faced with the network congestions that force validators on Ethereum to prioritize transactions with higher fees.

Optimistic rollups apply several mechanisms to reducing fees for users,
including batching transactions and compressing `calldata` to reduce data
publication costs. You can check the [L2 fee tracker(opens in a new
tab)](https://l2fees.info/) for a real-time overview of how much it costs to
use Ethereum-based optimistic rollups.

## How do optimistic rollups scale Ethereum?

As explained, optimistic rollups publish compressed transaction data on
Ethereum to guarantee data availability. The ability to compress data
published on-chain is crucial to scaling throughput on Ethereum with
optimistic rollups.

The main Ethereum chain places limits on how much data blocks can hold,
denominated in gas units (the [average block
size](/en/developers/docs/blocks/#block-size) is 15 million gas). While this
restricts how much gas each transaction can use, it also means we can increase
transactions processed per block by reducing transaction-related dataâ€”directly
improving scalability.

Optimistic rollups use several techniques to achieve transaction data
compression and improve TPS rates. For example, this [article(opens in a new
tab)](https://vitalik.eth.limo/general/2021/01/05/rollup.html) compares the
data a basic user transaction (sending ether) generates on Mainnet vs how much
data the same transaction generates on a rollup:

Parameter| Ethereum (L1)| Rollup (L2)  
---|---|---  
Nonce| ~3| 0  
Gasprice| ~8| 0-0.5  
Gas| 3| 0-0.5  
To| 21| 4  
Value| 9| ~3  
Signature| ~68 (2 + 33 + 33)| ~0.5  
From| 0 (recovered from sig)| 4  
**Total**| **~112 bytes**| **~12 bytes**  
  
Doing some rough calculations on these figures can help show the scalability
improvements afforded by an optimistic rollup:

  1. The target size for every block is 15 million gas and it costs 16 gas to verify one byte of data. Dividing the average block size by 16 gas (15,000,000/16) shows the average block can hold **937,500 bytes of data**.
  2. If a basic rollup transaction uses 12 bytes, then the average Ethereum block can process **78,125 rollup transactions** (937,5000/12) or **39 rollup batches** (if each batch holds an average of 2,000 transactions).
  3. If a new block is produced on Ethereum every 15 seconds, then the rollup's processing speeds would amount to roughly **5,208 transactions per second**. This is done by dividing the number of basic rollup transactions an Ethereum block can hold (**78,125**) by the average block time (**15 seconds**).

This is a fairly optimistic estimate, given that optimistic rollup
transactions cannot possibly comprise an entire block on Ethereum. However, it
can give a rough idea of how much scalability gains that optimistic rollups
can afford Ethereum users (current implementations offer up to 2,000 TPS).

The introduction of [data sharding](/en/roadmap/danksharding/) on Ethereum is
expected to improve scalability in optimistic rollups. Because rollup
transactions must share blockspace with other non-rollup transactions, their
processing capacity is limited by data throughput on the main Ethereum chain.
Danksharding will increase the space available to L2 chains to publish data
per block, using cheaper, impermanent "blob" storage instead of expensive,
permanent `CALLDATA`.

### Pros and cons of optimistic rollups

Pros| Cons  
---|---  
Offers massive improvements in scalability without sacrificing security or
trustlessness.| Delays in transaction finality due to potential fraud
challenges.  
Transaction data is stored on the layer 1 chain, improving transparency,
security, censorship-resistance, and decentralization.| Centralized rollup
operators (sequencers) can influence transaction ordering.  
Fraud proving guarantees trustless finality and allows honest minorities to
secure the chain.| If there are no honest nodes a malicious operator can steal
funds by posting invalid blocks and state commitments.  
Computing fraud proofs is open to regular L2 node, unlike validity proofs
(used in ZK-rollups) that require special hardware.| Security model relies on
at least one honest node executing rollup transactions and submitting fraud
proofs to challenge invalid state transitions.  
Rollups benefit from "trustless liveness" (anyone can force the chain to
advance by executing transactions and posting assertions)| Users must wait for
the one-week challenge period to expire before withdrawing funds back to
Ethereum.  
Optimistic rollups rely on well-designed cryptoeconomic incentives to increase
security on the chain.| Rollups must post all transaction data on-chain, which
can increase costs.  
Compatibility with EVM and Solidity allows developers to port Ethereum-native
smart contracts to rollups or use existing tooling to create new dapps.|  
  
### A visual explanation of optimistic rollups

More of a visual learner? Watch Finematics explain optimistic rollups:

### Use Optimistic rollups

Multiple implementations of Optimistic rollups exist that you can integrate
into your dapps:

#### Arbitrum One

* Fraud proofs only for whitelisted users, whitelist not open yet

  * [Website(opens in a new tab)](https://arbitrum.io/)
  * [Developer docs(opens in a new tab)](https://docs.arbitrum.io/welcome/get-started)
  * [Technology and risk summary(opens in a new tab)](https://l2beat.com/projects/arbitrum/)

#### Optimism

* Fault proofs in development

  * [Website(opens in a new tab)](https://optimism.io/)
  * [Developer docs(opens in a new tab)](https://docs.optimism.io/)
  * [Technology and risk summary(opens in a new tab)](https://l2beat.com/projects/optimism/)

#### Boba Network

* State validation in development

  * [Website(opens in a new tab)](https://boba.network/)
  * [Developer docs(opens in a new tab)](https://docs.boba.network/)
  * [Technology and risk summary(opens in a new tab)](https://l2beat.com/projects/bobanetwork/)

#### Base

* Fraud proof system is currently under development

  * [Website(opens in a new tab)](https://base.org/)
  * [Developer docs(opens in a new tab)](https://docs.base.org/)
  * [Technology and risk summary(opens in a new tab)](https://l2beat.com/scaling/projects/base)

## Further reading on optimistic rollups

  * [How do optimistic rollups work (The Complete guide)(opens in a new tab)](https://www.alchemy.com/overviews/optimistic-rollups)
  * [What is a Blockchain Rollup? A Technical Introduction(opens in a new tab)](https://www.ethereum-ecosystem.com/blog/what-is-a-blockchain-rollup-a-technical-introduction)
  * [The Essential Guide to Arbitrum(opens in a new tab)](https://newsletter.banklesshq.com/p/the-essential-guide-to-arbitrum)
  * [How does Optimism's Rollup really work?(opens in a new tab)](https://www.paradigm.xyz/2021/01/how-does-optimisms-rollup-really-work)
  * [OVM Deep Dive(opens in a new tab)](https://medium.com/ethereum-optimism/ovm-deep-dive-a300d1085f52)
  * [What is the Optimistic Virtual Machine?(opens in a new tab)](https://www.alchemy.com/overviews/optimistic-virtual-machine)

back-to-top â†‘

### Was this article helpful?

YesNo

![ðŸ‘ˆ](https://cdnjs.cloudflare.com/ajax/libs/twemoji/12.0.4/2/svg/1f448.svg)

Previous

[Scaling](/en/developers/docs/scaling/)

![ðŸ‘‰](https://cdnjs.cloudflare.com/ajax/libs/twemoji/12.0.4/2/svg/1f449.svg)

Next

[Zero-knowledge rollups](/en/developers/docs/scaling/zk-rollups/)

  * [Edit page(opens in a new tab)](https://github.com/ethereum/ethereum-org-website/tree/dev/public/content/developers/docs/scaling/optimistic-rollups/index.md)
  * On this page

    * Prerequisites
    * What is an optimistic rollup?
    * How do optimistic rollups interact with Ethereum?
      * Data availability
      * Censorship resistance
      * Settlement
    * How do optimistic rollups work?
      * Transaction execution and aggregation
      * State commitments
      * Fraud proving
      * L1/L2 interoperability
    * How do optimistic rollup fees work?
    * How do optimistic rollups scale Ethereum?
      * Pros and cons of optimistic rollups
      * A visual explanation of optimistic rollups
      * Use Optimistic rollups
    * Further reading on optimistic rollups

Website last updated: May 22, 2024

[(opens in a new tab)](https://github.com/ethereum/ethereum-org-
website)[(opens in a new tab)](https://twitter.com/ethdotorg)[(opens in a new
tab)](https://discord.gg/ethereum-org)

### Learn

  * [Learn Hub](/en/learn/)
  * [What is Ethereum?](/en/what-is-ethereum/)
  * [What is ether (ETH)?](/en/eth/)
  * [Ethereum wallets](/en/wallets/)
  * [What is Web3?](/en/web3/)
  * [Smart contracts](/en/smart-contracts/)
  * [Gas fees](/en/gas/)
  * [Run a node](/en/run-a-node/)
  * [Ethereum security and scam prevention](/en/security/)
  * [Quiz Hub](/en/quizzes/)
  * [Ethereum glossary](/en/glossary/)

### Use

  * [Guides](/en/guides/)
  * [Choose your wallet](/en/wallets/find-wallet/)
  * [Get ETH](/en/get-eth/)
  * [Dapps - Decentralized applications](/en/dapps/)
  * [Stablecoins](/en/stablecoins/)
  * [NFTs - Non-fungible tokens](/en/nft/)
  * [DeFi - Decentralized finance](/en/defi/)
  * [DAOs - Decentralized autonomous organizations](/en/dao/)
  * [Decentralized identity](/en/decentralized-identity/)
  * [Stake ETH](/en/staking/)
  * [Layer 2](/en/layer-2/)

### Build

  * [Builder's home](/en/developers/)
  * [Tutorials](/en/developers/tutorials/)
  * [Documentation](/en/developers/docs/)
  * [Learn by coding](/en/developers/learning-tools/)
  * [Set up local environment](/en/developers/local-environment/)
  * [Grants](/en/community/grants/)
  * [Foundational topics](/en/developers/docs/intro-to-ethereum/)
  * [UX/UI design fundamentals](/en/developers/docs/design-and-ux/)
  * [Enterprise - Mainnet Ethereum](/en/enterprise/)
  * [Enterprise - Private Ethereum](/en/enterprise/private-ethereum/)

### Participate

  * [Community hub](/en/community/)
  * [Online communities](/en/community/online/)
  * [Ethereum events](/en/community/events/)
  * [Contributing to ethereum.org](/en/contributing/)
  * [Translation Program](/en/contributing/translation-program/)
  * [Ethereum bug bounty program](/en/bug-bounty/)
  * [Ethereum Foundation](/en/foundation/)
  * [Ethereum Foundation Blog(opens in a new tab)](https://blog.ethereum.org/)
  * [Ecosystem Support Program(opens in a new tab)](https://esp.ethereum.foundation)
  * [Devcon(opens in a new tab)](https://devcon.org/)

### Research

  * [Ethereum Whitepaper](/en/whitepaper/)
  * [Ethereum roadmap](/en/roadmap/)
  * [Improved security](/en/roadmap/security/)
  * [Technical history of Ethereum](/en/history/)
  * [Open research](/en/community/research/)
  * [Ethereum Improvement Proposals](/en/eips/)
  * [Ethereum governance](/en/governance/)

  * [About us](/en/about/)
  * [Ethereum brand assets](/en/assets/)
  * [Code of conduct](/en/community/code-of-conduct/)
  * [Jobs](/en/about/#open-jobs)
  * [Privacy policy](/en/privacy-policy/)
  * [Terms of use](/en/terms-of-use/)
  * [Cookie policy](/en/cookie-policy/)
  * [Press Contact(opens in a new tab)](mailto:press@ethereum.org)

Is this page helpful?

### Validity proof

A security model for certain [layer 2](/en/glossary/#layer-2) solutions where,
to increase speed, transactions are rolled up into batches and submitted to
Ethereum in a single transaction. The transaction computation is done off-
chain and then supplied to the main chain with a proof of their validity. This
method increases the amount of transactions possible while maintaining
security. Some [rollups](/en/glossary/#rollups) use [fraud
proof](/en/glossary/#fraud-proof). [More on zero-knowledge
rollups](/en/developers/docs/scaling/zk-rollups/).

### Fraud proof

A security model for certain [layer 2](/en/glossary/#layer-2) solutions where,
to increase speed, transactions are [rolled up](/en/glossary/#rollups) into
batches and submitted to Ethereum in a single transaction. Other network
participants can re-execute the transactions to check that they were executed
honestly. If they uncover a discrepancy between the posted data and their own
version they can post a cryptographic proof that demonstrates where some fraud
took place. Some [rollups](/en/glossary/#rollups) use [validity
proofs](/en/glossary/#validity-proof).

