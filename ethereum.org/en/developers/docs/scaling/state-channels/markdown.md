Skip to main content

[](/en/)

  * Learn
  * Use
  * Build
  * Participate
  * Research

Search```K`

Languages EN

Change page

[Overview](/en/developers/docs/)

Foundational topics

[Intro to Ethereum](/en/developers/docs/intro-to-ethereum/)

[Intro to Ether](/en/developers/docs/intro-to-ether/)

[Intro to dapps](/en/developers/docs/dapps/)

[Web2 vs Web3](/en/developers/docs/web2-vs-web3/)

[Accounts](/en/developers/docs/accounts/)

[Transactions](/en/developers/docs/transactions/)

[Blocks](/en/developers/docs/blocks/)

[Ethereum virtual machine (EVM)](/en/developers/docs/evm/)

[Opcodes](/en/developers/docs/evm/opcodes/)

[Gas](/en/developers/docs/gas/)

[Nodes and clients](/en/developers/docs/nodes-and-clients/)

[Run a node](/en/developers/docs/nodes-and-clients/run-a-node/)

[Client diversity](/en/developers/docs/nodes-and-clients/client-diversity/)

[Nodes as a service](/en/developers/docs/nodes-and-clients/nodes-as-a-
service/)

[Node architecture](/en/developers/docs/nodes-and-clients/node-architecture/)

[Light clients](/en/developers/docs/nodes-and-clients/light-clients/)

[Archive nodes](/en/developers/docs/nodes-and-clients/archive-nodes/)

[Bootnodes](/en/developers/docs/nodes-and-clients/bootnodes/)

[Networks](/en/developers/docs/networks/)

[Consensus mechanisms](/en/developers/docs/consensus-mechanisms/)

[Proof-of-work](/en/developers/docs/consensus-mechanisms/pow/)

[Mining](/en/developers/docs/consensus-mechanisms/pow/mining/)

[Mining algorithms](/en/developers/docs/consensus-
mechanisms/pow/mining/mining-algorithms/)

[Dagger-Hashimoto](/en/developers/docs/consensus-mechanisms/pow/mining/mining-
algorithms/dagger-hashimoto/)

[Ethash](/en/developers/docs/consensus-mechanisms/pow/mining/mining-
algorithms/ethash/)

[Proof-of-stake](/en/developers/docs/consensus-mechanisms/pos/)

[Gasper](/en/developers/docs/consensus-mechanisms/pos/gasper/)

[Weak subjectivity](/en/developers/docs/consensus-mechanisms/pos/weak-
subjectivity/)

[Attestations](/en/developers/docs/consensus-mechanisms/pos/attestations/)

[PoS rewards and penalties](/en/developers/docs/consensus-
mechanisms/pos/rewards-and-penalties/)

[PoS attack and defense](/en/developers/docs/consensus-mechanisms/pos/attack-
and-defense/)

[Keys](/en/developers/docs/consensus-mechanisms/pos/keys/)

[Proof-of-stake versus proof-of-work](/en/developers/docs/consensus-
mechanisms/pos/pos-vs-pow/)

[Block proposal](/en/developers/docs/consensus-mechanisms/pos/block-proposal/)

[Proof-of-stake FAQs](/en/developers/docs/consensus-mechanisms/pos/faqs/)

[Proof-of-authority](/en/developers/docs/consensus-mechanisms/poa/)

Ethereum stack

[Intro to the stack](/en/developers/docs/ethereum-stack/)

[Smart contracts](/en/developers/docs/smart-contracts/)

[Smart contract languages](/en/developers/docs/smart-contracts/languages/)

[Smart contract anatomy](/en/developers/docs/smart-contracts/anatomy/)

[Smart contracts libraries](/en/developers/docs/smart-contracts/libraries/)

[Testing smart contracts](/en/developers/docs/smart-contracts/testing/)

[Compiling smart contracts](/en/developers/docs/smart-contracts/compiling/)

[Deploying smart contracts](/en/developers/docs/smart-contracts/deploying/)

[Verifying smart contracts](/en/developers/docs/smart-contracts/verifying/)

[Upgrading smart contracts](/en/developers/docs/smart-contracts/upgrading/)

[Smart contract security](/en/developers/docs/smart-contracts/security/)

[Smart contract formal verification](/en/developers/docs/smart-
contracts/formal-verification/)

[Composability](/en/developers/docs/smart-contracts/composability/)

[Development networks](/en/developers/docs/development-networks/)

[Development frameworks](/en/developers/docs/frameworks/)

Ethereum client APIs

[JavaScript APIs](/en/developers/docs/apis/javascript/)

[Backend APIs](/en/developers/docs/apis/backend/)

[JSON-RPC](/en/developers/docs/apis/json-rpc/)

[Data and analytics](/en/developers/docs/data-and-analytics/)

[Block explorers](/en/developers/docs/data-and-analytics/block-explorers/)

[Storage](/en/developers/docs/storage/)

[Integrated Development Environments (IDEs)](/en/developers/docs/ides/)

[Programming languages](/en/developers/docs/programming-languages/)

[Dart](/en/developers/docs/programming-languages/dart/)

[Delphi](/en/developers/docs/programming-languages/delphi/)

[.NET](/en/developers/docs/programming-languages/dot-net/)

[Golang](/en/developers/docs/programming-languages/golang/)

[Java](/en/developers/docs/programming-languages/java/)

[JavaScript](/en/developers/docs/programming-languages/javascript/)

[Python](/en/developers/docs/programming-languages/python/)

[Ruby](/en/developers/docs/programming-languages/ruby/)

[Rust](/en/developers/docs/programming-languages/rust/)

Advanced

[Bridges](/en/developers/docs/bridges/)

[Standards](/en/developers/docs/standards/)

[Token standards](/en/developers/docs/standards/tokens/)

[ERC-20: Fungible Tokens](/en/developers/docs/standards/tokens/erc-20/)

[ERC-721: NFTs](/en/developers/docs/standards/tokens/erc-721/)

[ERC-777](/en/developers/docs/standards/tokens/erc-777/)

[ERC-1155](/en/developers/docs/standards/tokens/erc-1155/)

[ERC-4626](/en/developers/docs/standards/tokens/erc-4626/)

[Maximal extractable value (MEV)](/en/developers/docs/mev/)

[Oracles](/en/developers/docs/oracles/)

[Scaling](/en/developers/docs/scaling/)

[Optimistic rollups](/en/developers/docs/scaling/optimistic-rollups/)

[Zero-knowledge rollups](/en/developers/docs/scaling/zk-rollups/)

[State channels](/en/developers/docs/scaling/state-channels/)

[Sidechains](/en/developers/docs/scaling/sidechains/)

[Plasma](/en/developers/docs/scaling/plasma/)

[Validium](/en/developers/docs/scaling/validium/)

[Data availability](/en/developers/docs/data-availability/)

[Networking layer](/en/developers/docs/networking-layer/)

[Network addresses](/en/developers/docs/networking-layer/network-addresses/)

[Portal Network](/en/developers/docs/networking-layer/portal-network/)

[Data structures and encoding](/en/developers/docs/data-structures-and-
encoding/)

[Patricia Merkle Trie](/en/developers/docs/data-structures-and-
encoding/patricia-merkle-trie/)

[Recursive-length prefix (RLP)](/en/developers/docs/data-structures-and-
encoding/rlp/)

[Simple serialize (SSZ)](/en/developers/docs/data-structures-and-
encoding/ssz/)

[Web3 secret storage definition](/en/developers/docs/data-structures-and-
encoding/web3-secret-storage/)

Design fundamentals

[Intro to design and UX](/en/developers/docs/design-and-ux/)

# State Channels

n

Last edit: [@nhsz(opens in a new tab)](https://github.com/nhsz), August 15,
2023

See contributors

On this page

  * Prerequisites
  * What are channels?
  * Payment channels
  * State channels
  * How state channels work
    * Opening the channel
    * Using the channel
    * Closing the channel
    * Settling disputes
    * How do state channels interact with Ethereum?
      * 1\. Liveness
      * 2\. Security
      * 3\. Finality
  * Virtual state channels
    * Virtual payment channels
  * Applications of state channels
    * Payments
    * Microtransactions
    * Decentralized applications
    * Atomic transfers
  * Drawbacks of using state channels
    * Liveness assumptions
    * Data unavailability
    * Liquidity issues
    * Griefing attacks
    * Predefined participant sets
    * Parallel transaction processing
  * Use state channels
  * Further reading

State channels allow participants to securely transact off-chain while keeping
interaction with Ethereum Mainnet at a minimum. Channel peers can conduct an
arbitrary number of off-chain transactions while only submitting two on-chain
transactions to open and close the channel. This allows for extremely high
transaction throughput and results in lower costs for users.

## Prerequisites

You should have read and understood our pages on [Ethereum
scaling](/en/developers/docs/scaling/) and [layer 2](/en/layer-2/).

## What are channels?

Public blockchains, such as Ethereum, face scalability challenges due to their
distributed architecture: on-chain transactions must be executed by all nodes.
Nodes have to be able to handle the volume of transactions in a block using
modest hardware, imposing a limit on the transaction throughput to keep the
network decentralized. Blockchain channels solve this problem by allowing
users to interact off-chain while still relying on the security of the main
chain for final settlement.

Channels are simple peer-to-peer protocols that allow two parties to make many
transactions between themselves and then only post the final results to the
blockchain. The channel uses cryptography to demonstrate that the summary data
they generate is truly the result of a valid set of intermediate transactions.
A ["multisig"](/en/developers/docs/smart-contracts/#multisig) smart contract
ensures the transactions are signed by the correct parties.

With channels, state changes are executed and validated by interested parties,
minimizing computation on Ethereum's execution layer. This decreases
congestion on Ethereum and also increases transaction processing speeds for
users.

Each channel is managed by a [multisig smart
contract](/en/developers/docs/smart-contracts/#multisig) running on Ethereum.
To open a channel, participants deploy the channel contract on-chain and
deposit funds into it. Both parties collectively sign a state update to
initialize the channel's state, after which they can transact quickly and
freely off-chain.

To close the channel, participants submit the last agreed-upon state of the
channel on-chain. Afterward, the smart contract distributes the locked funds
according to each participant's balance in the channel's final state.

Peer-to-peer channels are particularly useful for situations where some
predefined participants wish to transact with high frequency without incurring
visible overhead. Blockchain channels fall under two categories: **payment
channels** and **state channels**.

## Payment channels

A payment channel is best described as a "two-way ledger" collectively
maintained by two users. The ledger's initial balance is the sum of deposits
locked into the on-chain contract during the channel opening phase. Payment
channel transfers can be performed instantaneously and without the involvement
of the actual blockchain itself, except for an initial one-time on-chain
creation and an eventual closing of the channel.

Updates to the ledger's balance (i.e., the payment channel's state) require
the approval of all parties in the channel. A channel update, signed by all
channel participants, is considered finalized, much like a transaction on
Ethereum.

Payment channels were among the earliest scaling solutions designed to
minimize expensive on-chain activity of simple user interactions (e.g. ETH
transfers, atomic swaps, micropayments). Channel participants can conduct an
unlimited amount of instant, feeless transactions between each other as long
as the net sum of their transfers does not exceed the deposited tokens.

## State channels

Apart from supporting off-chain payments, payment channels have not proven
useful for handling general state transition logic. State channels were
created to solve this problem and make channels useful for scaling general-
purpose computation.

State channels still have a lot in common with payment channels. For example,
users interact by exchanging cryptographically signed messages (transactions),
which the other channel participants must also sign. If a proposed state
update isn't signed by all participants, it is considered invalid.

However, in addition to holding the user's balances, the channel also tracks
the current state of the contract's storage (i.e., values of contract
variables).

This makes it possible to execute a smart contract off-chain between two
users. In this scenario, updates to the smart contract's internal state
require only the approval of the peers who created the channel.

While this solves the scalability problem described earlier, it has
implications for security. On Ethereum, the validity of state transitions on
Ethereum is enforced by the network's consensus protocol. This makes it
impossible to propose an invalid update to a smart contract's state or alter
smart contract execution.

State channels don't have the same security guarantees. To some extent, a
state channel is a miniature version of Mainnet. With a limited set of
participants enforcing rules, the possibility of malicious behavior (e.g.,
proposing invalid state updates) increases. State channels derive their
security from a dispute arbitration system based on _fraud proofs_.

## How state channels work

Basically, the activity in a state channel is a session of interactions
involving users and a blockchain system. Users mostly communicate with each
other off-chain and only interact with the underlying blockchain to open the
channel, close the channel, or settle potential disputes between participants.

The following section outlines the basic workflow of a state channel:

### Opening the channel

Opening a channel requires participants to commit funds to a smart contract on
Mainnet. The deposit also functions as a virtual tab, so participating actors
can transact freely without needing to settle payments immediately. Only when
the channel is finalized on-chain do parties settle each other and withdraw
what's left of their tab.

This deposit also serves as a bond to guarantee honest behavior from each
participant. If depositors are found guilty of malicious actions during the
dispute resolution phase, the contract slashes their deposit.

Channel peers must sign an initial state, which they all agree upon. This
serves as the state channel's genesis, after which users can start
transacting.

### Using the channel

After initializing the channel's state, peers interact by signing transactions
and sending them to each other for approval. Participants initiate state
updates with these transactions and sign state updates from others. Each
transaction comprises the following:

  * A **nonce** , which acts as a unique ID for transactions and prevents replay attacks. It also identifies the order in which state updates occurred (which is important for dispute resolution)

  * The channel's old state

  * The channel's new state

  * The transaction which triggers the state transition (e.g., Alice sends 5 ETH to Bob)

State updates in the channel are not broadcasted on-chain as is normally the
case when users interact on Mainnet, which aligns with state channels' goal to
minimize on-chain footprint. As long as participants agree on state updates,
they are as final as an Ethereum transaction. Participants only need to depend
on Mainnet's consensus if a dispute arises.

### Closing the channel

Closing a state channel requires submitting the channel's final, agreed-upon
state to the on-chain smart contract. Details referenced in the state update
include the number of each participant's moves and a list of approved
transactions.

After verifying that the state update is valid (i.e., it is signed by all
parties) the smart contract finalizes the channel and distributes the locked
funds according to the channel's outcome. Payments made off-chain are applied
to Ethereum's state and each participant receives their remaining portion of
the locked funds.

The scenario described above represents what happens in the happy case.
Sometimes, users may be unable to reach an agreement and finalize the channel
(the sad case). Any of the following could be true of the situation:

  * Participants go offline and fail to propose state transitions

  * Participants refuse to co-sign valid state updates

  * Participants try to finalize the channel by proposing an old state update to the on-chain contract

  * Participants propose invalid state transitions for others to sign

Whenever consensus breaks down between participating actors in a channel, the
last option is to rely on Mainnet's consensus to enforce the channel's final,
valid state. In this case, closing the state channel requires settling
disputes on-chain.

### Settling disputes

Typically, parties in a channel agree on closing the channel beforehand and
co-sign the last state transition, which they submit to the smart contract.
Once the update is approved on-chain, execution of the off-chain smart
contract ends and participants exit the channel with their money.

However, one party can submit an on-chain request to end the smart contract's
execution and finalize the channelâ€”without waiting for their counterpart's
approval. If any of the consensus-breaking situations described earlier occur,
either party can trigger the on-chain contract to close the channel and
distribute funds. This provides **trustlessness** , ensuring that honest
parties can exit their deposits at any point, regardless of the other party's
actions.

To process the channel exit, the user must submit the application's last valid
state update to the on-chain contract. If this checks out (i.e., it bears the
signature of all parties), then funds are redistributed in their favor.

There is, however, a delay in executing single-user exit requests. If the
request to conclude the channel was unanimously approved, then the on-chain
exit transaction is executed immediately.

The delay comes into play in single-user exits due to the possibility of
fraudulent actions. For example, a channel participant may try to finalize the
channel on Ethereum by submitting an older state update on-chain.

As a countermeasure, state channels allow honest users to challenge invalid
state updates by submitting the latest, valid state of the channel on-chain.
State channels are designed such that newer, agreed-upon state updates trump
older state updates.

Once a peer triggers the on-chain dispute-resolution system, the other party
is required to respond within a time limit (called the challenge window). This
allows users to challenge the exit transaction, especially if the other party
is applying a stale update.

Whatever the case may be, channel users always have strong finality
guarantees: if the state transition in their possession was signed by all
members and is the most recent update, then it is of equal finality with a
regular on-chain transaction. They still have to challenge the other party on-
chain, but the only possible outcome is finalizing the last valid state, which
they hold.

### How do state channels interact with Ethereum?

Although they exist as off-chain protocols, state channels have an on-chain
component: the smart contract deployed on Ethereum when opening the channel.
This contract controls the assets deposited into the channel, verifies state
updates, and arbitrates disputes between participants.

State channels don't publish transaction data or state commitments to Mainnet,
unlike [layer 2](/en/layer-2/) scaling solutions. However, they are more
connected to Mainnet than, say,
[sidechains](/en/developers/docs/scaling/sidechains/), making them somewhat
safer.

State channels rely on the main Ethereum protocol for the following:

#### 1\. Liveness

The on-chain contract deployed when opening the channel is responsible for the
channel's functionality. If the contract is running on Ethereum, then the
channel is always available for usage. Conversely, a sidechain can always
fail, even if Mainnet is operational, putting user funds at risk.

#### 2\. Security

To some extent, state channels rely on Ethereum to provide security and
protect users from malicious peers. As discussed in later sections, channels
use a fraud proof mechanism that lets users challenge attempts to finalize the
channel with an invalid or stale update.

In this case, the honest party provides the latest valid state of the channel
as a fraud proof to the on-chain contract for verification. Fraud proofs
enable mutually distrustful parties to conduct off-chain transactions without
risking their funds in the process.

#### 3\. Finality

State updates collectively signed by channel users are considered as good as
on-chain transactions. Still, all in-channel activity only achieves true
finality when the channel is closed on Ethereum.

In the optimistic case, both parties can cooperate and sign the final state
update and submit on-chain to close the channel, after which the funds are
distributed according to the channel's final state. In the pessimistic case,
where someone tries to cheat by posting an incorrect state update on-chain,
their transaction isn't finalized until the challenge window elapses.

## Virtual state channels

The naive implementation of a state channel would be to deploy a new contract
when two users wish to execute an application off-chain. This is not only
infeasible, but it also negates the cost-effectiveness of state channels (on-
chain transaction costs can quickly add up).

To solve this problem, "virtual channels" were created. Unlike regular
channels that require on-chain transactions to open and terminate, a virtual
channel can be opened, executed, and finalized without interacting with the
main chain. It is even possible to settle disputes off-chain using this
method.

This system relies on the existence of so-called "ledger channels", which have
been funded on-chain. Virtual channels between two parties can be built on top
of an existing ledger channel, with the owner(s) of the ledger channel serving
as an intermediary.

Users in each virtual channel interact via a new contract instance, with the
ledger channel able to support multiple contract instances. The ledger
channel's state also contains more than one contract storage state, allowing
for parallel execution of applications off-chain between different users.

Just like regular channels, users exchange state updates to progress the state
machine. Except a dispute arises, the intermediary only has to be contacted
when opening or terminating the channel.

### Virtual payment channels

Virtual payment channels work off the same idea as virtual state channels:
participants connected to the same network can pass messages without needing
to open a new channel on-chain. In virtual payment channels, value transfers
are routed through one or more intermediaries, with guarantees that only the
intended recipient can receive transferred funds.

## Applications of state channels

### Payments

Early blockchain channels were simple protocols that allowed two participants
to conduct rapid, low-fee transfers off-chain without having to pay high
transaction fees on Mainnet. Today, payment channels are still useful for
applications designed for the exchange and deposits of ether and tokens.

Channel-based payments have the following advantages:

  1. **Throughput** : The amount of off-chain transactions per channel is unconnected to Ethereum's throughput, which is influenced by various factors, especially block size and block time. By executing transactions off-chain, blockchain channels can achieve higher throughput.

  2. **Privacy** : Because channels exist off-chain, details of interactions between participants are not recorded on Ethereum's public blockchain. Channel users only have to interact on-chain when funding and closing channels or settling disputes. Thus, channels are useful for individuals who desire more private transactions.

  3. **Latency** : Off-chain transactions conducted between channel participants can be settled instantly, if both parties cooperate, reducing delays. In contrast, sending a transaction on Mainnet requires waiting for nodes to process the transaction, produce a new block with the transaction, and reach consensus. Users may also need to wait for more block confirmations before considering a transaction finalized.

  4. **Cost** : State channels are particularly useful in situations where a set of participants will exchange many state updates over a long period. The only costs incurred are the opening and closing of the state channel smart contract; every state change between opening and closing the channel will be cheaper than the last as the settlement cost is distributed accordingly.

Implementing state channels on layer 2 solutions, such as
[rollups](/en/developers/docs/scaling/#rollups), could make them even more
attractive for payments. While channels offer cheap payments, the costs of
setting up the on-chain contract on Mainnet during the opening phase can be
get expensiveâ€”especially when gas fees spike. Ethereum-based rollups offer
[lower transaction fees(opens in a new tab)](https://l2fees.info/) and can
reduce overhead for channel participants by bringing down setup fees.

### Microtransactions

Microtransactions are low-value payments (e.g., lower than a fraction of a
dollar) that businesses cannot process without incurring losses. These
entities must pay payment service providers, which they cannot do if the
margin on customer payments is too low to make a profit.

Payment channels solve this problem by reducing the overhead associated with
microtransactions. For example, an Internet Service Provider (ISP) can open a
payment channel with a customer, allowing them to stream small payments each
time they use the service.

Beyond the cost of opening and closing the channel, participants don't incur
further costs on microtransactions (no gas fees). This is a win-win situation
since customers have more flexibility in how much they pay for services and
businesses don't lose out on profitable microtransactions.

### Decentralized applications

Like payment channels, state channels can make conditional payments according
to the state machine's final states. State channels can also support arbitrary
state transition logic, making them useful for executing generic apps off-
chain.

State channels are often limited to simple turn-based applications, as this
makes it easier to manage funds committed to the on-chain contract. Also, with
a limited number of parties updating the off-chain application's state at
intervals, punishing dishonest behavior is relatively straightforward.

The efficiency of a state channel application also depends on its design. For
example, a developer might deploy the app channel contract on-chain once and
allow other players to re-use the app without having to go on-chain. In this
case, the initial app channel serves as a ledger channel supporting multiple
virtual channels, each running a new instance of the app's smart contract off-
chain.

A potential use-case for state channel applications is simple two-player
games, where funds are distributed based on the game's outcome. The benefit
here is that players don't have to trust each other (trustlessness) and the
on-chain contract, not players, controls the allocation of funds and
settlement of disputes (decentralization).

Other possible use-cases for state channel apps include ENS name ownership,
NFT ledgers, and many more.

### Atomic transfers

Early payment channels were restricted to transfers between two parties,
limiting their usability. However, the introduction of virtual channels
allowed individuals to route transfers through intermediaries (i.e., multiple
p2p channels) without having to open a new channel on-chain.

Commonly described as "multi-hop transfers", routed payments are atomic (i.e.,
either all parts of the transaction succeed or it fails altogether). Atomic
transfers use [Hashed Timelock Contracts (HTLCs)(opens in a new
tab)](https://en.bitcoin.it/wiki/Hash_Time_Locked_Contracts) to ensure the
payment is released only if certain conditions are met, thereby reducing
counterparty risk.

## Drawbacks of using state channels

### Liveness assumptions

To ensure efficiency, state channels place time limits on the ability of
channel participants to respond to disputes. This rule assumes that peers will
always be online to monitor channel activity and contest challenges when
necessary.

In reality, users can go offline for reasons out of their control (e.g., poor
internet connection, mechanical failure, etc.). If an honest user goes
offline, a malicious peer can exploit the situation by presenting old
intermediate states to the adjudicator contract and stealing the committed
funds.

Some channels use "watchtowers"â€”entities responsible for watching on-chain
dispute events on behalf of others and taking necessary actions, like alerting
concerned parties. However, this can add to the costs of using a state
channel.

### Data unavailability

As explained earlier, challenging an invalid dispute requires presenting the
latest, valid state of the state channel. This is another rule based on an
assumptionâ€”that users have access to the channel's latest state.

Although expecting channel users to store copies of off-chain application
state is reasonable, this data may be lost due to error or mechanical failure.
If the user doesn't have the data backed up, they can only hope that the other
party doesn't finalize an invalid exit request using old state transitions in
their possession.

Ethereum users don't have to deal with this problem since the network enforces
rules on data availability. Transaction data is stored and propagated by all
nodes and available for users to download if and when necessary.

### Liquidity issues

To establish a blockchain channel, participants need to lock funds in an on-
chain smart contract for the channel's lifecycle. This reduces the liquidity
of channel users and also limits channels to those who can afford to keep
funds locked on Mainnet.

However, ledger channelsâ€”operated by an off-chain service provider (OSP)â€”can
reduce liquidity issues for users. Two peers connected to a ledger channel can
create a virtual channel, which they can open and finalize completely off-
chain, anytime they want.

Off-chain service providers could also open channels with multiple peers,
making them useful for routing payments. Of course, users must pay fees to
OSPs for their services, which may be undesirable for some.

### Griefing attacks

Griefing attacks are a common feature of fraud proof-based systems. A griefing
attack does not directly benefit the attacker but causes grief (i.e., harm) to
the victim, hence the name.

Fraud proving is susceptible to griefing attacks because the honest party must
respond to every dispute, even invalid ones, or risk losing their funds. A
malicious participant can decide to repeatedly post stale state transitions
on-chain, forcing the honest party to respond with the valid state. The cost
of those on-chain transactions can quickly add up, causing honest parties to
lose out in the process.

### Predefined participant sets

By design, the number of participants that comprise a state channel remains
fixed throughout its lifetime. This is because updating the participant set
would complicate the channel's operation, especially when funding the channel,
or settling disputes. Adding or removing participants would also require
additional on-chain activity, which increases overhead for users.

While this makes state channels easier to reason about, it limits the
usefulness of channel designs to application developers. This partly explains
why state channels have been dropped in favor of other scaling solutions, such
as rollups.

### Parallel transaction processing

Participants in the state channel send state updates in turns, which is why
they work best for "turn-based applications" (e.g., a two-player chess game).
This eliminates the need to handle simultaneous state updates and reduces the
work the on-chain contract must do to punish stale update posters. However, a
side-effect of this design is that transactions are dependent on each other,
increasing latency and diminishing the overall user experience.

Some state channels solve this problem by using a "full-duplex" design that
separates the off-chain state into two unidirectional "simplex" states,
allowing for concurrent state updates. Such designs improve off-chain
throughput and decrease transaction delays.

## Use state channels

Multiple projects provide implementations of state channels that you can
integrate into your dapps:

  * [Connext(opens in a new tab)](https://connext.network/)
  * [Kchannels(opens in a new tab)](https://www.kchannels.io/)
  * [Perun(opens in a new tab)](https://perun.network/)
  * [Raiden(opens in a new tab)](https://raiden.network/)
  * [Statechannels.org(opens in a new tab)](https://statechannels.org/)

## Further reading

**State channels**

  * [Making Sense of Ethereumâ€™s Layer 2 Scaling Solutions: State Channels, Plasma, and Truebit(opens in a new tab)](https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4) _â€“ Josh Stark, Feb 12 2018_
  * [State Channels - an explanation(opens in a new tab)](https://www.jeffcoleman.ca/state-channels/) _Nov 6, 2015 - Jeff Coleman_
  * [Basics of State Channels(opens in a new tab)](https://education.district0x.io/general-topics/understanding-ethereum/basics-state-channels/) _District0x_
  * [Blockchain State Channels: A State of the Art(opens in a new tab)](https://ieeexplore.ieee.org/document/9627997)

_Know of a community resource that helped you? Edit this page and add it!_

back-to-top â†‘

### Was this article helpful?

YesNo

![ðŸ‘ˆ](https://cdnjs.cloudflare.com/ajax/libs/twemoji/12.0.4/2/svg/1f448.svg)

Previous

[Zero-knowledge rollups](/en/developers/docs/scaling/zk-rollups/)

![ðŸ‘‰](https://cdnjs.cloudflare.com/ajax/libs/twemoji/12.0.4/2/svg/1f449.svg)

Next

[Sidechains](/en/developers/docs/scaling/sidechains/)

  * [Edit page(opens in a new tab)](https://github.com/ethereum/ethereum-org-website/tree/dev/public/content/developers/docs/scaling/state-channels/index.md)
  * On this page

    * Prerequisites
    * What are channels?
    * Payment channels
    * State channels
    * How state channels work
      * Opening the channel
      * Using the channel
      * Closing the channel
      * Settling disputes
      * How do state channels interact with Ethereum?
        * 1\. Liveness
        * 2\. Security
        * 3\. Finality
    * Virtual state channels
      * Virtual payment channels
    * Applications of state channels
      * Payments
      * Microtransactions
      * Decentralized applications
      * Atomic transfers
    * Drawbacks of using state channels
      * Liveness assumptions
      * Data unavailability
      * Liquidity issues
      * Griefing attacks
      * Predefined participant sets
      * Parallel transaction processing
    * Use state channels
    * Further reading

Website last updated: May 22, 2024

[(opens in a new tab)](https://github.com/ethereum/ethereum-org-
website)[(opens in a new tab)](https://twitter.com/ethdotorg)[(opens in a new
tab)](https://discord.gg/ethereum-org)

### Learn

  * [Learn Hub](/en/learn/)
  * [What is Ethereum?](/en/what-is-ethereum/)
  * [What is ether (ETH)?](/en/eth/)
  * [Ethereum wallets](/en/wallets/)
  * [What is Web3?](/en/web3/)
  * [Smart contracts](/en/smart-contracts/)
  * [Gas fees](/en/gas/)
  * [Run a node](/en/run-a-node/)
  * [Ethereum security and scam prevention](/en/security/)
  * [Quiz Hub](/en/quizzes/)
  * [Ethereum glossary](/en/glossary/)

### Use

  * [Guides](/en/guides/)
  * [Choose your wallet](/en/wallets/find-wallet/)
  * [Get ETH](/en/get-eth/)
  * [Dapps - Decentralized applications](/en/dapps/)
  * [Stablecoins](/en/stablecoins/)
  * [NFTs - Non-fungible tokens](/en/nft/)
  * [DeFi - Decentralized finance](/en/defi/)
  * [DAOs - Decentralized autonomous organizations](/en/dao/)
  * [Decentralized identity](/en/decentralized-identity/)
  * [Stake ETH](/en/staking/)
  * [Layer 2](/en/layer-2/)

### Build

  * [Builder's home](/en/developers/)
  * [Tutorials](/en/developers/tutorials/)
  * [Documentation](/en/developers/docs/)
  * [Learn by coding](/en/developers/learning-tools/)
  * [Set up local environment](/en/developers/local-environment/)
  * [Grants](/en/community/grants/)
  * [Foundational topics](/en/developers/docs/intro-to-ethereum/)
  * [UX/UI design fundamentals](/en/developers/docs/design-and-ux/)
  * [Enterprise - Mainnet Ethereum](/en/enterprise/)
  * [Enterprise - Private Ethereum](/en/enterprise/private-ethereum/)

### Participate

  * [Community hub](/en/community/)
  * [Online communities](/en/community/online/)
  * [Ethereum events](/en/community/events/)
  * [Contributing to ethereum.org](/en/contributing/)
  * [Translation Program](/en/contributing/translation-program/)
  * [Ethereum bug bounty program](/en/bug-bounty/)
  * [Ethereum Foundation](/en/foundation/)
  * [Ethereum Foundation Blog(opens in a new tab)](https://blog.ethereum.org/)
  * [Ecosystem Support Program(opens in a new tab)](https://esp.ethereum.foundation)
  * [Devcon(opens in a new tab)](https://devcon.org/)

### Research

  * [Ethereum Whitepaper](/en/whitepaper/)
  * [Ethereum roadmap](/en/roadmap/)
  * [Improved security](/en/roadmap/security/)
  * [Technical history of Ethereum](/en/history/)
  * [Open research](/en/community/research/)
  * [Ethereum Improvement Proposals](/en/eips/)
  * [Ethereum governance](/en/governance/)

  * [About us](/en/about/)
  * [Ethereum brand assets](/en/assets/)
  * [Code of conduct](/en/community/code-of-conduct/)
  * [Jobs](/en/about/#open-jobs)
  * [Privacy policy](/en/privacy-policy/)
  * [Terms of use](/en/terms-of-use/)
  * [Cookie policy](/en/cookie-policy/)
  * [Press Contact(opens in a new tab)](mailto:press@ethereum.org)

Is this page helpful?

### Fraud proof

A security model for certain [layer 2](/en/glossary/#layer-2) solutions where,
to increase speed, transactions are [rolled up](/en/glossary/#rollups) into
batches and submitted to Ethereum in a single transaction. Other network
participants can re-execute the transactions to check that they were executed
honestly. If they uncover a discrepancy between the posted data and their own
version they can post a cryptographic proof that demonstrates where some fraud
took place. Some [rollups](/en/glossary/#rollups) use [validity
proofs](/en/glossary/#validity-proof).

