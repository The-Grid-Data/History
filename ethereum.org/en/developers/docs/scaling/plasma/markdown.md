Skip to main content

[](/en/)

  * Learn
  * Use
  * Build
  * Participate
  * Research

Search```K`

Languages EN

Change page

This page is incomplete and we'd love your help. Edit this page and add
anything that you think might be useful to others.

[Overview](/en/developers/docs/)

Foundational topics

[Intro to Ethereum](/en/developers/docs/intro-to-ethereum/)

[Intro to Ether](/en/developers/docs/intro-to-ether/)

[Intro to dapps](/en/developers/docs/dapps/)

[Web2 vs Web3](/en/developers/docs/web2-vs-web3/)

[Accounts](/en/developers/docs/accounts/)

[Transactions](/en/developers/docs/transactions/)

[Blocks](/en/developers/docs/blocks/)

[Ethereum virtual machine (EVM)](/en/developers/docs/evm/)

[Opcodes](/en/developers/docs/evm/opcodes/)

[Gas](/en/developers/docs/gas/)

[Nodes and clients](/en/developers/docs/nodes-and-clients/)

[Run a node](/en/developers/docs/nodes-and-clients/run-a-node/)

[Client diversity](/en/developers/docs/nodes-and-clients/client-diversity/)

[Nodes as a service](/en/developers/docs/nodes-and-clients/nodes-as-a-
service/)

[Node architecture](/en/developers/docs/nodes-and-clients/node-architecture/)

[Light clients](/en/developers/docs/nodes-and-clients/light-clients/)

[Archive nodes](/en/developers/docs/nodes-and-clients/archive-nodes/)

[Bootnodes](/en/developers/docs/nodes-and-clients/bootnodes/)

[Networks](/en/developers/docs/networks/)

[Consensus mechanisms](/en/developers/docs/consensus-mechanisms/)

[Proof-of-work](/en/developers/docs/consensus-mechanisms/pow/)

[Mining](/en/developers/docs/consensus-mechanisms/pow/mining/)

[Mining algorithms](/en/developers/docs/consensus-
mechanisms/pow/mining/mining-algorithms/)

[Dagger-Hashimoto](/en/developers/docs/consensus-mechanisms/pow/mining/mining-
algorithms/dagger-hashimoto/)

[Ethash](/en/developers/docs/consensus-mechanisms/pow/mining/mining-
algorithms/ethash/)

[Proof-of-stake](/en/developers/docs/consensus-mechanisms/pos/)

[Gasper](/en/developers/docs/consensus-mechanisms/pos/gasper/)

[Weak subjectivity](/en/developers/docs/consensus-mechanisms/pos/weak-
subjectivity/)

[Attestations](/en/developers/docs/consensus-mechanisms/pos/attestations/)

[PoS rewards and penalties](/en/developers/docs/consensus-
mechanisms/pos/rewards-and-penalties/)

[PoS attack and defense](/en/developers/docs/consensus-mechanisms/pos/attack-
and-defense/)

[Keys](/en/developers/docs/consensus-mechanisms/pos/keys/)

[Proof-of-stake versus proof-of-work](/en/developers/docs/consensus-
mechanisms/pos/pos-vs-pow/)

[Block proposal](/en/developers/docs/consensus-mechanisms/pos/block-proposal/)

[Proof-of-stake FAQs](/en/developers/docs/consensus-mechanisms/pos/faqs/)

[Proof-of-authority](/en/developers/docs/consensus-mechanisms/poa/)

Ethereum stack

[Intro to the stack](/en/developers/docs/ethereum-stack/)

[Smart contracts](/en/developers/docs/smart-contracts/)

[Smart contract languages](/en/developers/docs/smart-contracts/languages/)

[Smart contract anatomy](/en/developers/docs/smart-contracts/anatomy/)

[Smart contracts libraries](/en/developers/docs/smart-contracts/libraries/)

[Testing smart contracts](/en/developers/docs/smart-contracts/testing/)

[Compiling smart contracts](/en/developers/docs/smart-contracts/compiling/)

[Deploying smart contracts](/en/developers/docs/smart-contracts/deploying/)

[Verifying smart contracts](/en/developers/docs/smart-contracts/verifying/)

[Upgrading smart contracts](/en/developers/docs/smart-contracts/upgrading/)

[Smart contract security](/en/developers/docs/smart-contracts/security/)

[Smart contract formal verification](/en/developers/docs/smart-
contracts/formal-verification/)

[Composability](/en/developers/docs/smart-contracts/composability/)

[Development networks](/en/developers/docs/development-networks/)

[Development frameworks](/en/developers/docs/frameworks/)

Ethereum client APIs

[JavaScript APIs](/en/developers/docs/apis/javascript/)

[Backend APIs](/en/developers/docs/apis/backend/)

[JSON-RPC](/en/developers/docs/apis/json-rpc/)

[Data and analytics](/en/developers/docs/data-and-analytics/)

[Block explorers](/en/developers/docs/data-and-analytics/block-explorers/)

[Storage](/en/developers/docs/storage/)

[Integrated Development Environments (IDEs)](/en/developers/docs/ides/)

[Programming languages](/en/developers/docs/programming-languages/)

[Dart](/en/developers/docs/programming-languages/dart/)

[Delphi](/en/developers/docs/programming-languages/delphi/)

[.NET](/en/developers/docs/programming-languages/dot-net/)

[Golang](/en/developers/docs/programming-languages/golang/)

[Java](/en/developers/docs/programming-languages/java/)

[JavaScript](/en/developers/docs/programming-languages/javascript/)

[Python](/en/developers/docs/programming-languages/python/)

[Ruby](/en/developers/docs/programming-languages/ruby/)

[Rust](/en/developers/docs/programming-languages/rust/)

Advanced

[Bridges](/en/developers/docs/bridges/)

[Standards](/en/developers/docs/standards/)

[Token standards](/en/developers/docs/standards/tokens/)

[ERC-20: Fungible Tokens](/en/developers/docs/standards/tokens/erc-20/)

[ERC-721: NFTs](/en/developers/docs/standards/tokens/erc-721/)

[ERC-777](/en/developers/docs/standards/tokens/erc-777/)

[ERC-1155](/en/developers/docs/standards/tokens/erc-1155/)

[ERC-4626](/en/developers/docs/standards/tokens/erc-4626/)

[Maximal extractable value (MEV)](/en/developers/docs/mev/)

[Oracles](/en/developers/docs/oracles/)

[Scaling](/en/developers/docs/scaling/)

[Optimistic rollups](/en/developers/docs/scaling/optimistic-rollups/)

[Zero-knowledge rollups](/en/developers/docs/scaling/zk-rollups/)

[State channels](/en/developers/docs/scaling/state-channels/)

[Sidechains](/en/developers/docs/scaling/sidechains/)

[Plasma](/en/developers/docs/scaling/plasma/)

[Validium](/en/developers/docs/scaling/validium/)

[Data availability](/en/developers/docs/data-availability/)

[Networking layer](/en/developers/docs/networking-layer/)

[Network addresses](/en/developers/docs/networking-layer/network-addresses/)

[Portal Network](/en/developers/docs/networking-layer/portal-network/)

[Data structures and encoding](/en/developers/docs/data-structures-and-
encoding/)

[Patricia Merkle Trie](/en/developers/docs/data-structures-and-
encoding/patricia-merkle-trie/)

[Recursive-length prefix (RLP)](/en/developers/docs/data-structures-and-
encoding/rlp/)

[Simple serialize (SSZ)](/en/developers/docs/data-structures-and-
encoding/ssz/)

[Web3 secret storage definition](/en/developers/docs/data-structures-and-
encoding/web3-secret-storage/)

Design fundamentals

[Intro to design and UX](/en/developers/docs/design-and-ux/)

# Plasma chains

w

Last edit: [@wackerow(opens in a new tab)](https://github.com/wackerow),
January 25, 2024

See contributors

On this page

  * Prerequisites
  * What is Plasma?
  * How does Plasma work?
    * Off-chain computation
    * State commitments
    * Entries and exits
      * Entering the plasma chain
      * Exiting the plasma chain
    * Dispute arbitration
  * The mass exit problem in plasma
  * Pros and cons of plasma
  * Plasma vs layer 2 scaling protocols
    * Efficiency
    * Support for smart contracts
    * Data unavailability
    * Mass exit problem
  * How does Plasma differ from sidechains and sharding?
    * Plasma vs sidechains
    * Plasma vs sharding
    * Use Plasma
  * Further reading

A Plasma chain is a separate blockchain anchored to Ethereum Mainnet but
executing transactions off-chain with its own mechanism for block validation.
Plasma chains are sometimes referred to as "child" chains, essentially smaller
copies of the Ethereum Mainnet. Plasma chains use _fraud proofs_ (like
[optimistic rollups](/en/developers/docs/scaling/optimistic-rollups/)) to
arbitrate disputes.

Merkle trees enable the creation of an endless stack of these chains that can
work to offload bandwidth from parent chains (including Ethereum Mainnet).
However, while these chains derive some security from Ethereum (via fraud
proofs), their security and efficiency are affected by several design
limitations.

## Prerequisites

You should have a good understanding of all the foundational topics and a
high-level understanding of [Ethereum scaling](/en/developers/docs/scaling/).

## What is Plasma?

Plasma is a framework for improving scalability in public blockchains like
Ethereum. As described in the original [Plasma whitepaper(opens in a new
tab)](http://plasma.io/plasma.pdf), Plasma chains are built atop another
blockchain (called a "root chain"). Each "child chain" extends from the root
chain and is generally managed by a smart contract deployed on the parent
chain.

The Plasma contract functions, among other things, as a
[bridge](/en/developers/docs/bridges/) allowing users to move assets between
Ethereum Mainnet and the plasma chain. Although this makes them similar to
[sidechains](/en/developers/docs/scaling/sidechains/), plasma chains
benefitâ€”at least, to some extentâ€”from Ethereum Mainnet's security. This is
unlike sidechains that are solely responsible for their security.

## How does Plasma work?

The basic components of the Plasma framework are:

### Off-chain computation

Ethereum's current processing speed is limited to ~ 15-20 transactions per
second, reducing the short-term possibility of scaling to handle more users.
This problem exists mainly because Ethereum's [consensus
mechanism](/en/developers/docs/consensus-mechanisms/) requires many peer-to-
peer nodes to verify every update to the blockchain's state.

Although Ethereum's consensus mechanism is necessary for security, it may not
apply to every use case. For example, Alice may not need her daily payments to
Bob for a cup of coffee verified by the entire Ethereum network since some
trust exists between both parties.

Plasma supposes that Ethereum Mainnet doesn't need to verify all transactions.
Instead, we can process transactions off Mainnet, freeing nodes from having to
validate every transaction.

Off-chain computation is necessary since Plasma chains can optimize for speed
and cost. For example, a Plasma chain mayâ€”and most often doesâ€”use a single
"operator" to manage the ordering and execution of transactions. With just one
entity verifying transactions, processing times on a plasma chain are faster
than Ethereum Mainnet.

### State commitments

While Plasma executes transactions off-chain, they are settled on the main
Ethereum execution layerâ€”otherwise, Plasma chains cannot benefit from
Ethereum's security guarantees. But finalizing off-chain transactions without
knowing the state of the plasma chain would break the security model and allow
the proliferation of invalid transactions. This is why the operator, the
entity responsible for producing blocks on the plasma chain, is required to
publish "state commitments" on Ethereum periodically.

A [commitment scheme(opens in a new
tab)](https://en.wikipedia.org/wiki/Commitment_scheme) is a cryptographic
technique for committing to a value or statement without revealing it to
another party. Commitments are "binding" in the sense that you cannot change
the value or statement once you've committed to it. State commitments in
Plasma take the form of "Merkle roots" (derived from a [Merkle
tree](/en/whitepaper/#merkle-trees)) which the operator sends at intervals to
the Plasma contract on the Ethereum chain.

Merkle roots are cryptographic primitives that enable compressing of large
amounts of information. A Merkle root (also called a "block root" in this
case) could represent all the transactions in a block. Merkle roots also make
it easier to verify that a small piece of data is part of the larger dataset.
For instance, a user can produce a [Merkle
proof](/en/developers/tutorials/merkle-proofs-for-offline-data-
integrity/#main-content) to prove the inclusion of a transaction in a specific
block.

Merkle roots are important for providing information about the off-chain's
state to Ethereum. You can think of Merkle roots as "save points": the
operator is saying, "This is the state of the Plasma chain at x point in time,
and this is the Merkle root as proof." The operator is committing to the
_current state_ of the plasma chain with a Merkle root, which is why it is
called a "state commitment".

### Entries and exits

For Ethereum users to take advantage of Plasma, there needs to be a mechanism
for moving funds between Mainnet and plasma chains. We cannot arbitrarily send
ether to an address on the plasma chain, thoughâ€”these chains are incompatible,
so the transaction would either fail or lead to lost funds.

Plasma uses a master contract running on Ethereum to process user entries and
exits. This master contract is also responsible for tracking state commitments
(explained earlier) and punishing dishonest behavior via fraud proofs (more on
this later).

#### Entering the plasma chain

To enter the plasma chain, Alice (the user) will have to deposit ETH or any
ERC-20 token in the plasma contract. The plasma operator, who watches contract
deposits, recreates an amount equal to Alice's initial deposit and releases it
to her address on the plasma chain. Alice is required to attest to receiving
the funds on the child chain and can then use these funds for transactions.

#### Exiting the plasma chain

Exiting the plasma chain is more complex than entering it for several reasons.
The biggest one is that, while Ethereum has information about the plasma
chain's state, it cannot verify if the information is true or not. A malicious
user could make an incorrect assertion ("I have 1000 ETH") and get away with
providing fake proofs to back up the claim.

To prevent malicious withdrawals, a "challenge period" is introduced. During
the challenge period (usually a week), anyone can challenge a withdrawal
request using a fraud-proof. If the challenge succeeds, then the withdrawal
request is denied.

However, it is usually the case that users are honest and make correct claims
about the funds they own. In this scenario, Alice will initiate a withdrawal
request on the root chain (Ethereum) by submitting a transaction to the plasma
contract.

She must also provide a Merkle proof verifying that a transaction creating her
funds on the Plasma chain was included in a block. This is necessary for
iterations of Plasma, such as [Plasma MVP(opens in a new
tab)](https://www.learnplasma.org/en/learn/mvp.html), that use a [Unspent
Transaction Output (UTXO)(opens in a new
tab)](https://en.wikipedia.org/wiki/Unspent_transaction_output) model.

Others, like [Plasma Cash(opens in a new
tab)](https://www.learnplasma.org/en/learn/cash.html), represent funds as
[non-fungible tokens](/en/developers/docs/standards/tokens/erc-721/) instead
of UTXOs. Withdrawing, in this case, requires proof of ownership of tokens on
the Plasma chain. This is done by submitting the two latest transactions
involving the token and providing a Merkle proof verifying the inclusion of
those transactions in a block.

The user must also add a bond to the withdrawal request as a guarantee of
honest behavior. If a challenger proves Alice's withdrawal request invalid,
her bond is slashed, and some of it goes to the challenger as a reward.

If the challenge period elapses without anyone providing a fraud-proof,
Alice's withdrawal request is considered valid, allowing her to retrieve
deposits from the Plasma contract on Ethereum.

### Dispute arbitration

Like any blockchain, plasma chains need a mechanism for enforcing the
integrity of transactions in case participants act maliciously (e.g. double-
spending funds). To this end, plasma chains use fraud proofs to arbitrate
disputes concerning the validity of state transitions and penalize bad
behavior. Fraud proofs are used as a mechanism through which a Plasma child
chain files a complaint to its parent chain or to the root chain.

A fraud-proof is simply a claim that a particular state transition is invalid.
An example is if a user (Alice) tries to spend the same funds twice. Perhaps
she spent the UTXO in a transaction with Bob and wants to spend the same UTXO
(which is now Bob's) in another transaction.

To prevent the withdrawal, Bob will construct a fraud-proof by providing
evidence of Alice spending the said UTXO in a previous transaction and a
Merkle proof of the transaction's inclusion in a block. The same process works
in Plasma Cashâ€”Bob would need to provide proof that Alice earlier transferred
the tokens she's trying to withdraw.

If Bob's challenge succeeds, Alice's withdrawal request is canceled. However,
this approach relies on Bob's ability to watch the chain for withdrawal
requests. If Bob is offline, then Alice can process the malicious withdrawal
once the challenge period elapses.

## The mass exit problem in plasma

The mass exit problem occurs when a large number of users try to withdraw from
a plasma chain at the same time. Why this problem exists has to do with one of
Plasma's biggest problems: **data unavailability**.

Data availability is the ability to verify that the information for a proposed
block was actually published on the blockchain network. A block is
"unavailable" if the producer publishes the block itself but withholds data
used to create the block.

Blocks must be available if nodes are to be able to download the block and
verify the validity of transactions. Blockchains ensure data availability by
forcing block producers to post all transaction data on-chain.

Data availability also helps with securing off-chain scaling protocols that
build on Ethereum's base layer. By forcing operators on these chains to
publish transaction data on Ethereum, anyone can challenge invalid blocks by
constructing fraud proofs referencing the correct state of the chain.

Plasma chains primarily store transaction data with the operator and **do not
publish any data on Mainnet** (i.e., besides periodic state commitments). This
means users must rely on the operator to provide block data if they need to
create fraud proofs challenging invalid transactions. If this system works,
then users can always use fraud proofs to secure funds.

The problem starts when the operator, not just any user, is the party acting
maliciously. Because the operator is in sole control of the blockchain, they
have more incentive to advance invalid state transitions on a larger scale,
such as stealing funds belonging to users on the plasma chain.

In this case, using the classic fraud-proof system does not work. The operator
could easily make an invalid transaction transferring Alice and Bob's funds to
their wallet and hide the data necessary for creating the fraud-proof. This is
possible because the operator isn't required to make data available to users
or Mainnet.

Therefore, the most optimistic solution is to attempt a "mass exit" of users
from the plasma chain. The mass exit slows down the malicious operator's plan
to steal funds and provides some measure of protection for users. Withdrawal
requests are ordered based on when each UTXO (or token) was created,
preventing malicious operators from front-running honest users.

Nonetheless, we still need a way to verify the validity of withdrawal requests
during a mass exitâ€”to prevent opportunistic individuals from cashing in on the
chaos processing invalid exits. The solution is simple: require users to post
the last **valid state of the chain** to exit their money.

But this approach still has problems. For instance, if all users on a plasma
chain need to exit (which is possible in the case of a malicious operator),
then the entire valid state of the plasma chain must be dumped on Ethereum's
base layer at once. With the arbitrary size of plasma chains (high throughput
= more data) and constraints on Ethereum's processing speeds, this is not an
ideal solution.

Although exit games sound nice in theory, real-life mass exits will likely
trigger network-wide congestion on Ethereum itself. Besides harming Ethereum's
functionality, a poorly coordinated mass exit means that users may be unable
to withdraw funds before the operator drains every account on the plasma
chain.

## Pros and cons of plasma

Pros| Cons  
---|---  
Offers high throughput and low cost per transaction.| Does not support general
computation (cannot run smart contracts. Only basic token transfers, swaps,
and a few other transaction types are supported via predicate logic.  
Good for transactions between arbitrary users (no overhead per user pair if
both are established on the plasma chain)| Need to periodically watch the
network (liveness requirement) or delegate this responsibility to someone else
to ensure the security of your funds.  
Plasma chains can be adapted to specific use-cases that are unrelated to the
main chain. Anyone, including businesses, can customize Plasma smart contracts
to provide scalable infrastructure that works in different contexts.| Relies
on one or more operators to store data and serve it upon request.  
Reduces load on Ethereum Mainnet by moving computation and storage off-chain.|
Withdrawals are delayed by several days to allow for challenges. For fungible
assets, this can be mitigated by liquidity providers, but there is an
associated capital cost.  
| If too many users try to exit simultaneously, Ethereum Mainnet could get
congested.  
  
## Plasma vs layer 2 scaling protocols

While Plasma was once considered a useful scaling solution for Ethereum, it
has since been dropped in favor of [layer 2 (L2) scaling
protocols](/en/layer-2/). L2 scaling solutions remedy several of Plasma's
problems:

### Efficiency

[Zero-Knowledge rollups](/en/developers/docs/scaling/zk-rollups/) generate
cryptographic proofs of the validity of each batch of transactions processed
off-chain. This prevents the users (and operators) from advancing invalid
state transitions, eliminating the need for challenge periods and exit games.
It also means users don't have to watch the chain periodically to secure their
funds.

### Support for smart contracts

Another problem with the plasma framework was [the inability to support the
execution of Ethereum smart contracts(opens in a new
tab)](https://ethresear.ch/t/why-smart-contracts-are-not-feasible-on-
plasma/2598/4). As a result, most implementations of Plasma were mostly built
for simple payments or the exchange of ERC-20 tokens.

Conversely, optimistic rollups, are compatible with the [Ethereum Virtual
Machine](/en/developers/docs/evm/) and can run Ethereum-native [smart
contracts](/en/developers/docs/smart-contracts/), making them a useful and
_secure_ solution for scaling [decentralized
applications](/en/developers/docs/dapps/). Similarly, plans are underway to
[create a zero-knowledge implementation of the EVM (zkEVM)(opens in a new
tab)](https://ethresear.ch/t/a-zk-evm-specification/11549) that would allow
ZK-rollups to process arbitrary logic and execute smart contracts.

### Data unavailability

As explained earlier, plasma suffers from a data availability problem. If a
malicious operator advanced an invalid transition on the plasma chain, users
would be unable to challenge it since the operator can withhold data needed to
create the fraud-proof. Rollups solve this problem by forcing operators to
post transaction data on Ethereum, allowing anyone to verify the chain's state
and create fraud proofs if necessary.

### Mass exit problem

ZK-rollups and optimistic rollups both solve Plasma's mass exit problem in
various ways. For example, a ZK-rollup relies on cryptographic mechanisms that
ensure operators cannot steal user funds under any scenario.

Similarly, optimistic rollups impose a delay period on withdrawals during
which anyone can initiate a challenge and prevent malicious withdrawal
requests. While this is similar to Plasma, the difference is that verifiers
have access to data needed to create fraud proofs. Thus, there's no need for
rollup users to engage in a frenzied, "first-to-get-out" migration to Ethereum
Mainnet.

## How does Plasma differ from sidechains and sharding?

Plasma, sidechains, and sharding are fairly similar because they all connect
to Ethereum Mainnet in some way. However, the level and strength of these
connections vary, which affects the security properties of each scaling
solution.

### Plasma vs sidechains

A [sidechain](/en/developers/docs/scaling/sidechains/) is an independently
operated blockchain connected to Ethereum Mainnet via a two-way bridge.
[Bridges](/en/bridges/) allow users to exchange tokens between the two
blockchains to transact on the sidechain, reducing congestion on Ethereum
Mainnet and improving scalability. Sidechains use a separate consensus
mechanism and are typically much smaller than Ethereum Mainnet. As a result,
bridging assets to these chains involves increased risk; given the lack of
security guarantees inherited from Ethereum Mainnet in the sidechain model,
users risk the loss of funds in an attack on the sidechain.

Conversely, plasma chains derive their security from Mainnet. This makes them
measurably more secure than sidechains. Both sidechains and plasma chains can
have different consensus protocols, but the difference is that plasma chains
publish Merkle roots for each block on Ethereum Mainnet. Block roots are small
pieces of information we can use to verify information about transactions that
happen on a plasma chain. If an attack happens on a plasma chain, users can
safely withdraw their funds back to Mainnet using the appropriate proofs.

### Plasma vs sharding

Both plasma chains and shard chains periodically publish cryptographic proofs
to Ethereum Mainnet. However, both have different security properties.

Shard chains commit "collation headers" to Mainnet containing detailed
information about each data shard. Nodes on Mainnet verify and enforce the
validity of data shards, reducing the possibility of invalid shard transitions
and protecting the network against malicious activity.

Plasma is different because Mainnet only receives minimal information about
the state of child chains. This means Mainnet cannot effectively verify
transactions conducted on child chains, making them less secure.

**Note** that sharding the Ethereum blockchain is no longer on the roadmap. It
has been superseded by scaling via rollups and
[Danksharding](/en/roadmap/danksharding/).

### Use Plasma

Multiple projects provide implementations of Plasma that you can integrate
into your dapps:

  * [Polygon(opens in a new tab)](https://polygon.technology/) (previously Matic Network)

## Further reading

  * [Learn Plasma(opens in a new tab)](https://www.learnplasma.org/en/)
  * [A quick reminder of what "shared security" means and why it's so important(opens in a new tab)](https://old.reddit.com/r/ethereum/comments/sgd3zt/a_quick_reminder_of_what_shared_security_means/)
  * [Sidechains vs Plasma vs Sharding(opens in a new tab)](https://vitalik.eth.limo/general/2019/06/12/plasma_vs_sharding.html)
  * [Understanding Plasma, Part 1: The Basics(opens in a new tab)](https://www.theblockcrypto.com/amp/post/10793/understanding-plasma-part-1-the-basics)
  * [The Life and Death of Plasma(opens in a new tab)](https://medium.com/dragonfly-research/the-life-and-death-of-plasma-b72c6a59c5ad#)

_Know of a community resource that helped you? Edit this page and add it!_

## Help us with this page

If you're an expert on the topic and want to contribute, edit this page and
sprinkle it with your wisdom.

You'll be credited and you'll be helping the Ethereum community!

Use this flexible [documentation template(opens in a new
tab)](https://www.notion.so/efdn/Writer-
template-4b40d196cde7422ca6a2091de33550bd)

Questions? Ask us in the #content channel on our [Discord server(opens in a
new tab)](https://discord.gg/ethereum-org)

[Edit page(opens in a new tab)](https://github.com/ethereum/ethereum-org-
website/tree/dev/public/content/developers/docs/scaling/plasma/index.md)

back-to-top â†‘

### Was this article helpful?

YesNo

![ðŸ‘ˆ](https://cdnjs.cloudflare.com/ajax/libs/twemoji/12.0.4/2/svg/1f448.svg)

Previous

[Sidechains](/en/developers/docs/scaling/sidechains/)

![ðŸ‘‰](https://cdnjs.cloudflare.com/ajax/libs/twemoji/12.0.4/2/svg/1f449.svg)

Next

[Validium](/en/developers/docs/scaling/validium/)

  * [Edit page(opens in a new tab)](https://github.com/ethereum/ethereum-org-website/tree/dev/public/content/developers/docs/scaling/plasma/index.md)
  * On this page

    * Prerequisites
    * What is Plasma?
    * How does Plasma work?
      * Off-chain computation
      * State commitments
      * Entries and exits
        * Entering the plasma chain
        * Exiting the plasma chain
      * Dispute arbitration
    * The mass exit problem in plasma
    * Pros and cons of plasma
    * Plasma vs layer 2 scaling protocols
      * Efficiency
      * Support for smart contracts
      * Data unavailability
      * Mass exit problem
    * How does Plasma differ from sidechains and sharding?
      * Plasma vs sidechains
      * Plasma vs sharding
      * Use Plasma
    * Further reading

Website last updated: May 22, 2024

[(opens in a new tab)](https://github.com/ethereum/ethereum-org-
website)[(opens in a new tab)](https://twitter.com/ethdotorg)[(opens in a new
tab)](https://discord.gg/ethereum-org)

### Learn

  * [Learn Hub](/en/learn/)
  * [What is Ethereum?](/en/what-is-ethereum/)
  * [What is ether (ETH)?](/en/eth/)
  * [Ethereum wallets](/en/wallets/)
  * [What is Web3?](/en/web3/)
  * [Smart contracts](/en/smart-contracts/)
  * [Gas fees](/en/gas/)
  * [Run a node](/en/run-a-node/)
  * [Ethereum security and scam prevention](/en/security/)
  * [Quiz Hub](/en/quizzes/)
  * [Ethereum glossary](/en/glossary/)

### Use

  * [Guides](/en/guides/)
  * [Choose your wallet](/en/wallets/find-wallet/)
  * [Get ETH](/en/get-eth/)
  * [Dapps - Decentralized applications](/en/dapps/)
  * [Stablecoins](/en/stablecoins/)
  * [NFTs - Non-fungible tokens](/en/nft/)
  * [DeFi - Decentralized finance](/en/defi/)
  * [DAOs - Decentralized autonomous organizations](/en/dao/)
  * [Decentralized identity](/en/decentralized-identity/)
  * [Stake ETH](/en/staking/)
  * [Layer 2](/en/layer-2/)

### Build

  * [Builder's home](/en/developers/)
  * [Tutorials](/en/developers/tutorials/)
  * [Documentation](/en/developers/docs/)
  * [Learn by coding](/en/developers/learning-tools/)
  * [Set up local environment](/en/developers/local-environment/)
  * [Grants](/en/community/grants/)
  * [Foundational topics](/en/developers/docs/intro-to-ethereum/)
  * [UX/UI design fundamentals](/en/developers/docs/design-and-ux/)
  * [Enterprise - Mainnet Ethereum](/en/enterprise/)
  * [Enterprise - Private Ethereum](/en/enterprise/private-ethereum/)

### Participate

  * [Community hub](/en/community/)
  * [Online communities](/en/community/online/)
  * [Ethereum events](/en/community/events/)
  * [Contributing to ethereum.org](/en/contributing/)
  * [Translation Program](/en/contributing/translation-program/)
  * [Ethereum bug bounty program](/en/bug-bounty/)
  * [Ethereum Foundation](/en/foundation/)
  * [Ethereum Foundation Blog(opens in a new tab)](https://blog.ethereum.org/)
  * [Ecosystem Support Program(opens in a new tab)](https://esp.ethereum.foundation)
  * [Devcon(opens in a new tab)](https://devcon.org/)

### Research

  * [Ethereum Whitepaper](/en/whitepaper/)
  * [Ethereum roadmap](/en/roadmap/)
  * [Improved security](/en/roadmap/security/)
  * [Technical history of Ethereum](/en/history/)
  * [Open research](/en/community/research/)
  * [Ethereum Improvement Proposals](/en/eips/)
  * [Ethereum governance](/en/governance/)

  * [About us](/en/about/)
  * [Ethereum brand assets](/en/assets/)
  * [Code of conduct](/en/community/code-of-conduct/)
  * [Jobs](/en/about/#open-jobs)
  * [Privacy policy](/en/privacy-policy/)
  * [Terms of use](/en/terms-of-use/)
  * [Cookie policy](/en/cookie-policy/)
  * [Press Contact(opens in a new tab)](mailto:press@ethereum.org)

Is this page helpful?

### Fraud proof

A security model for certain [layer 2](/en/glossary/#layer-2) solutions where,
to increase speed, transactions are [rolled up](/en/glossary/#rollups) into
batches and submitted to Ethereum in a single transaction. Other network
participants can re-execute the transactions to check that they were executed
honestly. If they uncover a discrepancy between the posted data and their own
version they can post a cryptographic proof that demonstrates where some fraud
took place. Some [rollups](/en/glossary/#rollups) use [validity
proofs](/en/glossary/#validity-proof).

