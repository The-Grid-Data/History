[](/)

  * Building 
    * [Firedancer](/firedancer/)
    * [the Pit](/thepit/)
    * [Cyclone](/cyclone/)
  * Thinking 
    * [Writing](/writing/)
    * [Research](/research/)
  * [Connect](/connect/)

  * [Building](/)
    * [Firedancer](/firedancer/)
    * [the Pit](/thepit/)
    * [Cyclone](/cyclone/)
    * [Collaborations](/collaborations/)
  * [Thinking](/writing/)
    * [Writing](/writing/)
    * [Research](/research/)
    * [Media](/media/)
  * [About](/writing/)
    * [Chronicle](/chronicle/)
    * [Validator](/validator-security/)
    * [Brand & Press](/brand/)
    * [Connect](/connect/)

[](https://twitter.com/jump_)[](https://github.com/JumpCrypto)[](https://www.youtube.com/@jump_)

[Terms of Use_](/terms-of-use/)[Privacy Policy_](/data-protection-and-privacy-
policy/)[Disclaimers_](/nfa/)

![](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTM2NSIgaGVpZ2h0PSI3MTEiIHZpZXdCb3g9IjAgMCAxMzY1IDcxMSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgb3BhY2l0eT0iMC4zIj4KPHJlY3QgeT0iOTIuNzM5MSIgd2lkdGg9IjE0Mi45NzMiIGhlaWdodD0iNjEuODI2MSIgZmlsbD0iIzBFMjE0NyIvPgo8cmVjdCB4PSIxNzMuODg2IiB5PSIyNzguMjE4IiB3aWR0aD0iNDYzLjY5NiIgaGVpZ2h0PSI2MS44MjYxIiBmaWxsPSIjMEUyMTQ3Ii8+CjxwYXRoIGQ9Ik0xNzMuODg2IDM3MC45NTZINDQwLjUxMVY0MzIuNzgySDE3My44ODZWMzcwLjk1NloiIGZpbGw9IiMwRTIxNDciLz4KPHJlY3QgeD0iMTczLjg4NiIgeT0iNDYzLjY5NiIgd2lkdGg9IjM3OC42ODUiIGhlaWdodD0iNjEuODI2MSIgZmlsbD0iIzBFMjE0NyIvPgo8cmVjdCB4PSIxNzMuODg2IiB5PSI5Mi43MzkxIiB3aWR0aD0iNDg2Ljg4IiBoZWlnaHQ9IjYxLjgyNjEiIGZpbGw9IiMwRTIxNDciLz4KPHJlY3QgeD0iNjY3LjI2IiB5PSIyNzguNDkyIiB3aWR0aD0iNDA1LjczNCIgaGVpZ2h0PSI2MS44MjYxIiBmaWxsPSIjMEUyMTQ3Ii8+CjxyZWN0IHg9IjQ3MS40MjUiIHk9IjM3MC45NTYiIHdpZHRoPSI1MTAuMDY1IiBoZWlnaHQ9IjYxLjgyNjEiIGZpbGw9IiMwRTIxNDciLz4KPHJlY3QgeD0iMTAxMi40IiB5PSIzNzAuOTU2IiB3aWR0aD0iMjgyLjA4MiIgaGVpZ2h0PSI2MS44MjYxIiBmaWxsPSIjMEUyMTQ3Ii8+CjxyZWN0IHg9IjkyLjczOTMiIHk9IjE4NS40NzgiIHdpZHRoPSI0MDUuNzM0IiBoZWlnaHQ9IjYxLjgyNjEiIGZpbGw9IiMwRTIxNDciLz4KPHJlY3QgeD0iOTIuNzM5MyIgeT0iNTU2LjQzNSIgd2lkdGg9IjIzOS41NzYiIGhlaWdodD0iNjEuODI2MSIgZmlsbD0iIzBFMjE0NyIvPgo8cmVjdCB4PSI1ODMuNDgzIiB5PSI0NjMuNjk2IiB3aWR0aD0iMjg1Ljk0NiIgaGVpZ2h0PSI2MS44MjYxIiBmaWxsPSIjMEUyMTQ3Ii8+CjxyZWN0IHg9IjkwMC44MDIiIHk9IjQ2My42MzEiIHdpZHRoPSIxNjIuMjEzIiBoZWlnaHQ9IjYyLjEyNDIiIGZpbGw9IiMwRTIxNDciLz4KPHJlY3QgeD0iNjkxLjY4MSIgeT0iOTIuNzM5MSIgd2lkdGg9IjI5Ny41MzgiIGhlaWdodD0iNjEuODI2MSIgZmlsbD0iIzBFMjE0NyIvPgo8cmVjdCB4PSI1OTguOTQiIHk9IjE4NS40NzgiIHdpZHRoPSIyOTcuNTM4IiBoZWlnaHQ9IjYxLjgyNjEiIGZpbGw9IiMwRTIxNDciLz4KPHJlY3QgeD0iMTAyMC40NSIgeT0iOTMuMTg2MyIgd2lkdGg9IjI3My44MDciIGhlaWdodD0iNjAuOTczOCIgZmlsbD0iIzBFMjE0NyIvPgo8cmVjdCB4PSI5OTYuOTQ2IiB5PSIxODUuNDc4IiB3aWR0aD0iMjk3LjUzOCIgaGVpZ2h0PSI2MS44MjYxIiBmaWxsPSIjMEUyMTQ3Ii8+CjxyZWN0IHg9IjEwOTMuNzkiIHk9IjQ2My4xNDQiIHdpZHRoPSIzOC42NDEzIiBoZWlnaHQ9IjYxLjgyNjEiIGZpbGw9IiMwRTIxNDciLz4KPHJlY3QgeD0iNTI5LjM4NiIgeT0iMTg1LjQ3OCIgd2lkdGg9IjM4LjY0MTMiIGhlaWdodD0iNjEuODI2MSIgZmlsbD0iIzBFMjE0NyIvPgo8cmVjdCB4PSI5MjcuMzkxIiB5PSIxODUuNDc4IiB3aWR0aD0iMzguNjQxMyIgaGVpZ2h0PSI2MS44MjYxIiBmaWxsPSIjMEUyMTQ3Ii8+CjxyZWN0IHg9IjEzMjUuNCIgeT0iMTg1LjQ3OCIgd2lkdGg9IjM4LjY0MTMiIGhlaWdodD0iNjEuODI2MSIgZmlsbD0iIzBFMjE0NyIvPgo8cmVjdCB4PSIzNjMuMjI4IiB5PSI1NTYuNDM1IiB3aWR0aD0iMzguNjQxMyIgaGVpZ2h0PSI2MS44MjYxIiBmaWxsPSIjMEUyMTQ3Ii8+CjxyZWN0IHk9IjY0OS4xNzQiIHdpZHRoPSIzOC42NDEzIiBoZWlnaHQ9IjYxLjgyNjEiIGZpbGw9IiMwRTIxNDciLz4KPHJlY3Qgd2lkdGg9IjE0MyIgaGVpZ2h0PSI2MiIgZmlsbD0iIzBFMjE0NyIvPgo8L2c+Cjwvc3ZnPgo=)

# Gaming Infrastructure Part 2: Introduction to ARC

![Dev Bharel](https://jumpcrypto-
com.ghost.io/content/images/2023/01/Group-9777-2.png)

###### Dev Bharel

![Shanav K Mehta](https://jumpcrypto-
com.ghost.io/content/images/2023/01/avarat-7.png)

###### Shanav K Mehta

[Gaming](/writing/gaming/)[Infrastructure](/writing/infrastructure/)[Research](/writing/research/)

Jan 09 2023 _ 7 min read

![Gaming Infrastructure Part 2: Introduction to ARC](https://jumpcrypto-
com.ghost.io/content/images/2023/01/Blog--Introduction--to-ARC.png)

## Overview

In the [last post,](https://jumpcrypto.com/defining-on-chain-
gaming/?ref=jumpcrypto.com) we discussed three types of on-chain games, namely
(i) fully on-chain games (FOC), (ii) on-chain assets (OCA), and (iii) optional
cosmetic mints (OCM). To recap, most game studios today opt for the OCM
approach due to limited available infrastructure to pursue FOC and OCA without
introducing substantial user friction. Over the next few articles, we will
highlight some of the infrastructure that could enable fully on-chain games
(FOC) and on-chain assets (OCA), along with rough designs of what each
component might look like in production.

The first piece of infrastructure needed is an efficient system to manage
assets as well as game state on-chain. Defining how the asset operates on-
chain has meaningful downstream implications on asset programmability (e.g.
permissioning, metadata updates etc). To better understand what such a system
could look like, we decided to build our own on-chain game (more on this
later) and rapidly found that traditional object-oriented programming
(OOP)-based approaches run into scalability challenges as asset dependencies
increase linearly as the scope of the game expands.

As a result, we decided to experiment with data-oriented design patterns that
have been long used by traditional game developers but have scarcely been
experimented with on-chain. Through this process, we experimented with a
framework we call **ARC (Action Registry Core)** on Solana that we believe is
one of the most efficient ways to manage on-chain assets and game logic. ARC
is inspired by a data-oriented architectural pattern called **ECS (Entity
Component System)** that is often used in traditional game development.

In this article, we will go over how ECS works, why it is important in
traditional games, how this philosophy could be extended to build a framework
like ARC, and what the underlying architecture would look like.

Our goal from this exercise is to contribute to open research and help push
on-chain gaming infrastructure forward. In that spirit, we have decided to
open source our reference implementation of ARC and welcome any feedback from
the community.

[_**Link to ARC GitHub**_](https://github.com/JumpCrypto/sol-
arc?ref=jumpcrypto.com)

## What Is ECS in Traditional Game Development?

ECS, or (”Entity Component System”), is an architecture that’s been widely
adopted in recent years for video games. Compared to classic Object-Oriented
Programming (OOP), ECS has a number of benefits for video games as it
separates data from behavior. In traditional web2 games, this has great
performance boosts (improved cache locality) while also maintaining better
logic controls while developing the game itself.

A helpful way to understand the benefits of ECS is to understand the
shortcomings of traditional OOP in scenarios with multiple dependencies.

### Challenges with OOP - The Diamond Problem

Let’s say we’re building a very simple game which has the following
properties:

  * Three entities: i) `Mammal`, ii) `Fish`, iii) `Amphibian`
  * `Mammal` can breathe on land but not in water
  * `Fish` can breathe in water but not on land
  * `Amphibian` can breathe both in water and on land

In traditional OOP, `Mammal` could be an entity than inherits from a base
class `LandBreather` and `Fish`could be an entity than inherits from a base
class `WaterBreather`. We run into a challenge with `Amphibian` here where it
has the properties of both `LandBreather` and `WaterBreather` but cannot
inherit from both. In classic OOP, this is called the “Diamond Problem.” This
problem is more prevalent in games than other applications as the number of
game characters, items, and asset compounds with increasing characteristics
and dependencies. While some workarounds exist, for gaming, we believe ECS is
the most elegant solution

### ECS as a Solution

An ECS-based game has the following properties:

  * Entities - unique identifiers or containers for components
  * Components - plain data types without behavior, that can be “attached” to entities
  * Systems - functions matched with entities that have a certain set of components

Entities can contain zero or more components. Entities can add/remove/modify
their components dynamically through the use of Systems.

To understand how ECS solves the constraints faced by OOP within games, let’s
use ECS to solve for the example above. Under ECS we would create two
components: `LandBreather` and `WaterBreather`. The system
`LandBreatherSystem` handles movement of any entity with the `LandBreather`
component and `WaterBreatherSystem` handles movement of any entity with the
`WaterBreather` component. Entities could then look as follows:

  * `Mammal`: [`LandBreather`]
  * `Fish`: [`WaterBreather`]
  * `Amphibian`:  [`LandBreather`, `WaterBreather`]

You can then dynamically add more components to entities such as `Fly` or
`Fight` and create more entities with varying components under them.

![](https://jumpcrypto-com.ghost.io/content/images/2023/01/Untitled--22-.png)

## What Is ARC?

ARC (Action Registry Core) is a framework for organizing information on-chain
that is inspired by traditional ECS architecture. Like traditional ECS, ARC
has entities that are data-less containers for components and components that
are plain data types without behavior that can be “attached” to entities.

Unlike ECS, ARC has ‘actions’ instead of ‘systems’ that can execute against
specific components. The primary distinction is that systems in traditional
ECS are built around a loop-based architecture used in traditional games,
whereas action bundles account for the fact that blockchain architecture is
push-based. The specific implementation of ARC outlined here is for the Solana
ecosystem, but a similar architecture could be used in other ecosystems as
well. The basic structure for ARC is a three-layered onion. First, you have
the Core, which is in charge of maintaining the Registries and Entities.
Secondly, you have various Registry contracts, that maintain registrations for
Components and Actions, along with _governance_ features. And finally, you
have the (optional) games or Actions contracts that modify components.

![](https://jumpcrypto-com.ghost.io/content/images/2023/01/1--1-.png)

### The Core:

The Core is in charge of exactly three things:

  * Initiation of new Registry instances
  * Minting of new entities either as NFTs or standalone entity PDAs
  * Maintenance of `SerializedComponents` with respect to an entity

Only _one_ Core program ever needs to exist on the chain, as Registry
Instances are how we bucket different components, entities, and rules. On EVM
chains this approach might not work, as contract storage is limited per
contract, meaning it might be better to launch multiple Cores.

Specifically in Solana, the Entity structure is similar to Metaplex Metadata
generated for each Metaplex NFT. One significant difference is the new mapping
of _one Entity per Registry instance on a given token_. This means that one
token could theoretically hold multiple entities, as long as they belong to
different Registries (will likely have different components, component values,
etc).

It’s an open question if this behavior is “better” than _one_ entity per
token. Because the Core only deals with _serialized_ components, it doesn’t
need to worry about how to deserialize anything. This means all
deserialization logic can be pushed to the game, or Actions level.

A Registry instance is a unique identifier given to a Registry and its
instance ID. Different instances help instantiate different “games” in the
same Core, allowing for reuse of the same Registry Governance code for a given
set of components and Action — just allowing for different instantiations of
entities.

    
    
    #[account]
    pub struct Entity {
        pub components: Vec<SerializedComponents>
    }
    
    pub struct SerializedComponent{
        pub component_key: Pubkey,
        pub max_size: u64,
        pub data: Vec<u8>,
    }
    

### The Registry:

The Registry Program is basically a governance contract. It keeps track of:

  * Registered Components by their Schema URL.
  * Registered Actions that can modify a given Component for a given Registry Instance.
  * The ability to create new instances of the Registry.

For example, it might say that only an admin is allowed to create new
instances of the Registry, or it might give that authority up to a DAO.

Same with any components that are registered with it. For example, let’s say
for given Game X, there exists a Move Action that lets players move pieces
from one tile to another at a speed of 1 tile per second. Another team comes
along to create “Portals” in this Registry that allow for faster travel. To
allow the Portal Action to be able to modify the “Location” component on
Units, requires the governance of the Registry to vote on if this is a change
in the rules of the Registry they allow. They might allow it for a specific
Registry Instance (you can use it on the “Portals Server” but not on the
“Hardcore Server”) for example.

The update authority on components is the Registry, since Actions only submit
their proposed changes to the Registry, which then checks governance and then
submits the changes to the Core to modify the entity. This crucially means
that Actions **_don’t need to be on-chain games_.** They can be off-chain
gaming infra, like Oracles, which submit changes to an on-chain asset layer
that’s controlled by the Game DAO.

    
    
    #[account]
    pub struct ActionBundleRegistration{
        pub system: Pubkey,
        pub instance: u64,
        pub components: Vec<Pubkey>, //PDA of the Component Schema
    }
    

### The Action Bundles:

Actions are on-chain or off-chain code that is capable of:

  * Reading Entity PDA & deserializing the components they find valuable.
  * Modifying and submitting a changed serialized component (or a set of components) back to the Registry to be updated with the entity.

The application-specific Actions code allows for “layers” of games. For
example, there might exist “Objective: King of the Hill” and “Objective:
Kills” Actions. From these two Actions, _three_ possible games could be
played. A Registry instance could be instantiated that allows only the first
Action, the second Action, or both to be active and allow changes to
components.

    
    
    mod ActionBundle {
    	pub fn move_troops() -> Result<()> {..}
    	pub fn capture_points() -> Result<()> {..}
    	..
    }
    

## Benefits of ARC for On-Chain Games

ARC has several benefits for fully on-chain games (FOC) and on-chain assets
(OCA), including:

  * **Backwards compatibility** on schema changes.
  * Because entities can hold dynamic components, you could maintain both v1 and v2 of a component.
  * This allows older applications to query and not lose operational support.
  * **Efficiency** **-** Entities are only as big as they need to be thanks to their size being determined by the components they have.
  * **Repeatability** \- The same implementation can be used across ecosystems fairly easily because the base implementation is very simple.
  * **Familiarity** \- web2 gaming companies are more familiar with this framework.
  * **Modularity** \- Adding new properties/behaviors as requirements change is modular.
  * **Extensibility** \- On-chain asset layer is useful for both hybrid games with off-chain oracles that change state for entities and fully on-chain games that read and modify state.
  * **Cross-chain accessibility -** A simple cross-chain serialization framework and cross-chain identity framework can ease portability to other chains. More on this in future articles.

## Conclusion

Overall, ARC is a framework for managing a game’s on-chain asset layer that
supports fully on-chain games and those that leverage on-chain assets. This
architecture offers scalability, as volume and interdependency of game assets
increase and avoid technical debt that may come with an OOP-based approach. In
future articles, we will dive deeper into the usage of an ARC-based on-chain
games backend and explore other infrastructure that is required to complete
the stack.

_Special thanks to Joe Howarth, Ben Huan, Anirudh Suresh and many others for
valuable feedback!_

Share

![](/static/subscribe2-825809a798c6960f978785c6581f4afb.svg)

#### Stay up to date with the latest from Jump_

​

.Subscribe

#### More articles

![SAFU: Creating a Standard for Whitehats](https://jumpcrypto-
com.ghost.io/content/images/2022/10/Standards-for-Whitehats-Thread---
blog.png)SAFU: Creating a Standard for WhitehatsWhitehats and DeFi protocols
need a shared understanding of security policy. We propose the SAFU - Simple
Arrangement for Funding Upload - as a versatile and credible way to let
whitehats know what to...](/writing/safu-creating-a-standard-for-whitehats/)

Oct 24 2022 _ 17 min

Share

[![Huckleberry: IBC Event Hallucinations](https://jumpcrypto-
com.ghost.io/content/images/2023/09/New-Blog-Post.png)Huckleberry: IBC Event
HallucinationsThis blog post describes a vulnerability in ibc-go, the
reference implementation of the Interblockchain Communication Protocol (IBC)
used by most Cosmos blockchains](/writing/huckleberry-ibc-event-
hallucinations/)

Sep 06 2023 _ 4 min

Share

[![Mapping Markets: Evaluating Blockchain’s Mass Adoption
Potential](https://jumpcrypto-com.ghost.io/content/images/2023/06/Blog---
Mapping-Markets_-Evaluating-Blockchain-s-Mass-Adoption-Potential.png)Mapping
Markets: Evaluating Blockchain’s Mass Adoption PotentialIn this post, we
propose a geographically-oriented framework, which we call “Pueyo Maps”
(inspired by Tomas Pueyo’s geo-history), as a way of evaluating the long-term
suitability of blockchain-based s...](/writing/mapping-markets-blockchain-
mass-adoption-potential/)

Jun 05 2023 _ 20 min

Share

Disclaimer

The information on this website and on the Brick by Brick podcast or Ship Show
Twitter spaces is provided for informational, educational, and entertainment
purposes only.  This information is not intended to be and does not constitute
financial advice, investment advice, trading advice, or any other type of
advice.  You should not make any decision – financial, investment, trading or
otherwise – based on any of the information presented here without undertaking
your own due diligence and consulting with a financial adviser.  Trading,
including that of digital assets or cryptocurrency, has potential rewards as
well as potential risks involved. Trading may not be suitable for all
individuals. Recordings of podcast episodes or Twitter spaces events may be
used in the future.

![](data:image/svg+xml;charset=utf-8,%3Csvg height='619' width='1338'
xmlns='http://www.w3.org/2000/svg' version='1.1'%3E%3C/svg%3E)

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAD0lEQVQoz2NgGAWjYBgCAALZAAHP5sSUAAAAAElFTkSuQmCC)![](/static/bb55dfe76137757a150d8db409a314e1/80e7e/brandLines.svg)

###### Building_

  * [Firedancer](/firedancer/)
  * [the Pit](/thepit/)
  * [Cyclone](/cyclone/)

###### Thinking_

  * [Writing](/writing/)
  * [Research](/research/)

###### About_

  * [Validator Security](/validator-security/)
  * [Connect](/connect/)

[Terms of Use_](/terms-of-use/)[Privacy Policy_](/data-protection-and-privacy-
policy/)[Disclaimers_](/nfa/)

© 2024 Jump Crypto. All Rights Reserved.

Jump Crypto does not operate any business lines that accept funds from
external investors. Any person, company, or app purporting to accept external
investor funds on behalf of Jump Crypto is fraudulent.

